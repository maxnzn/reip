#!/usr/bin/env python
_G='round'
_F='max'
_E='min'
_D='name'
_C='overrides'
_B='flexs'
_A=True
import contextlib as __stickytape_contextlib
@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
	import tempfile as B,shutil as C;A=B.mkdtemp()
	try:yield A
	finally:C.rmtree(A)
with __stickytape_temporary_dir()as __stickytape_working_dir:
	def __stickytape_write_module(path,contents):
		import os,os.path
		def A(path):
			B=path.split('/');A=__stickytape_working_dir
			for C in B:
				A=os.path.join(A,C)
				if not os.path.exists(A):
					os.mkdir(A)
					with open(os.path.join(A,'__init__.py'),'wb')as D:D.write(b'\n')
		A(os.path.dirname(path));B=os.path.join(__stickytape_working_dir,path)
		with open(B,'wb')as C:C.write(contents)
	import sys as __stickytape_sys;__stickytape_sys.path.insert(0,__stickytape_working_dir);__stickytape_write_module('model/simulation.py',b'from helpers.status import systemiserStatusMessage\nfrom model.set_initial_state import set_initial_state\nfrom model.sim_base_demand import simBaseDemands\nfrom model.sim_phase_1 import simPhase1\nfrom model.sim_phase_2 import simPhase2\nfrom model.sim_phase_3 import simPhase3\nfrom model.sim_phase_4 import simPhase4\nfrom model.track_metrics import trackMetrics\nfrom model.update_emissions_levels import updateEmissionLevels\nfrom model.update_firming_control import updateFirmingControl\nfrom model.update_store_levels import updateStoreLevels\nfrom results.results import annual_results, cost_and_revenue, create_results_object\n\n\ndef run_model(s, settings):\n\n    d = {}\n    simBaseDemands(s, settings, d)\n    set_initial_state(s, settings, d)\n\n\n    for i in range(settings["simLength"]):\n        systemiserStatusMessage(str(i))\n        simPhase1(i, s, settings)\n        simPhase2(i, s, settings)\n    #    simPhase3(i, s, settings) # I think it\'s possible to get away with this, because the number of layers in the networ has been reduced\n        simPhase4(i, s, settings)\n        updateStoreLevels(i, s, settings)\n        updateEmissionLevels(i, s, settings)\n        updateFirmingControl(i, s)\n        trackMetrics(i, s)\n    return s\n\n\ndef build_results(s, settings, units):\n    results, resultsKeys = create_results_object(s, settings)\n    annualResults, checks = annual_results(settings, results, resultsKeys, units)\n    cost_revenue_answer = cost_and_revenue(annualResults, settings, s)\n    return {\n        **cost_revenue_answer,\n        "results": results,\n        "checks": checks,\n        "annualResults": annualResults,\n    }\n\n\ndef simulation(s, settings, units):\n    state = run_model(s, settings)\n    calc_results = build_results(s, settings, units)\n    return {\n        "s": state,\n        "results": calc_results,\n    }\n');__stickytape_write_module('helpers/status.py',b'def systemiserStatusMessage(message: str):\n    statusAvailable = "__sysUpdateStatus" in globals()\n    if statusAvailable:\n        globals()["__sysUpdateStatus"](message)\n');__stickytape_write_module('model/set_initial_state.py',b'def flag_hours_in_range(start_hour, finish_hour, total_hours=8760):\n    flagged_hours = [0] * total_hours\n    hours_in_day = 24\n\n    for day in range(total_hours // hours_in_day):\n        for hour in range(start_hour, finish_hour):\n            flagged_hours[day * hours_in_day + hour] = 1\n\n    return flagged_hours\n\n\n\ndef set_initial_state(s, settings, d):\n    s["firmingAllowedDict"][0] = 1\n    initialStoreLevelsNames = [\n        "electricity",\n        "water",\n        "h2",\n    #    "mp1StoreLevel",\n    #    "nh3StoreLevel",\n    #    "lohcStoreLevel",\n        "iron",\n    #    "fertStoreLevel",\n    ]\n    for n in initialStoreLevelsNames:\n        label0 = n + "StorePercentHour0"\n        labelCapacity = n + "StoreCapacity"\n        label = n + "StoreLevel"\n        s[label + "Dict"][0] = settings[label0] * settings[labelCapacity]\n        s[label] = settings[label0] * settings[labelCapacity]  # store levels are both settings and state...\n\n    s[\'optimised\'] = {\n        "solarPvCapacity": settings["solarPvCapacity"],\n        "windTurbinesCapacity": settings["windTurbinesCapacity"],\n        "gasTurbinesCapacity": settings["gasTurbinesCapacity"],\n        "electricityStoreCapacity": settings["electricityStoreCapacity"],\n    }\n\n    s["benchmarkEnergyInput"] = d["electricityBaseDemand"]/d["ironBaseDemand"]\n    s["ironPriceAfterCarbon"] = (settings["ironMarketValue"]*1000 \n                                 + settings["ironMarketEmissionsIntensity"]*settings["carbonPrice"])\n    s["ironValueAdd"] = s["ironPriceAfterCarbon"] - settings["ironOreUnitCost"]\n    s["breakevenElectricityPrice"] = s["ironValueAdd"]/s["benchmarkEnergyInput"]\n\n    """(by hour): kWh required * (0.0147+0.0009)\n    (day): 128.7 + kVA_peak * 0.243 [5-9pm] + kVA anytime * 0.0719 [!5-9pm]\n    """\n    s["networkHourlyStandingCharge"] = settings["electricityGridNetworkDailyCharge"]/24\n    kvaGridCapacity = 1000 * settings["gridElectricityCapacity"] / settings["electricityGridPowerFactor"]\n    kvaPeakHourlyCharge = kvaGridCapacity * settings["electricityGridKvaPeakDailyCharge"]/24\n    kvaOffPeakHourlyCharge = kvaGridCapacity * settings["electricityGridKvaOffPeakDailyCharge"]/24\n\n    flaggedHours = flag_hours_in_range(settings["electricityGridPeakStart"], settings["electricityGridPeakFinish"], settings["simLength"])\n\n    for i in range(settings["simLength"]):\n        if flaggedHours[i] == 1:\n            s["electricityGridKvaCharge"][i] = kvaPeakHourlyCharge\n        if flaggedHours[i] == 0:\n            s["electricityGridKvaCharge"][i] = kvaOffPeakHourlyCharge\n\n\n');__stickytape_write_module('model/sim_base_demand.py',b'\nfrom re import S\nfrom model.functions import (\n    calcDistributeDemand,\n    calcProduceDemand,\n    calcProduceInputDemand,\n    calcStoreDemand,\n)\n\n# def electricityPriceCheck\n\ndef simBaseDemands(s, settings,d):\n\n\n    d["ironDistributeDemand"] = settings["ironDistributeCapacity"]\n\n    d["ironBaseDemand"] = d["ironDistributeDemand"]\n\n    d["ironProduceDemand"] = calcProduceDemand(settings["ironProduceCapacity"],d["ironDistributeDemand"], 0)\n\n    d["ironPostPProduceDemand"] = d["ironProduceDemand"]\n    d["ironRawProduceDemand"] = d["ironPostPProduceDemand"] * settings["ironRawToIronPostP"]\n    d["ironPrePProduceDemand"] = d["ironRawProduceDemand"] * settings["ironPrePToIronRaw"]\n\n    d["ironPrePWaterDemand"] = calcProduceInputDemand(d["ironPrePProduceDemand"],settings["waterToIronPreP"])\n\n    d["ironRawWaterDemand"] = calcProduceInputDemand(d["ironRawProduceDemand"],settings["waterToIronRaw"])\n    d["ironPostPWaterDemand"] = calcProduceInputDemand(d["ironPostPProduceDemand"],settings["waterToIronPostP"])\n    d["ironWaterDemand"] = d["ironPrePWaterDemand"] + d["ironRawWaterDemand"] + d["ironPostPWaterDemand"]\n\n    d["ironPrePH2Demand"] = calcProduceInputDemand(d["ironPrePProduceDemand"],settings["h2ToIronPreP"])\n\n    d["ironRawH2Demand"] = calcProduceInputDemand(d["ironRawProduceDemand"], settings["h2ToIronRaw"])\n    d["ironPostPH2Demand"] = calcProduceInputDemand(d["ironPostPProduceDemand"],settings["h2ToIronPostP"])\n    d["ironH2Demand"] = d["ironPrePH2Demand"] + d["ironRawH2Demand"] + d["ironPostPH2Demand"]\n\n    d["ironPrePElectricityDemand"] = calcProduceInputDemand(d["ironPrePProduceDemand"],settings["electricityToIronPreP"])\n    d["ironRawElectricityDemand"] = calcProduceInputDemand(d["ironRawProduceDemand"],settings["electricityToIronRaw"])\n    d["ironPostPElectricityDemand"] = calcProduceInputDemand(d["ironPostPProduceDemand"],settings["electricityToIronPostP"])\n    d["ironElectricityDemand"] = d["ironPrePElectricityDemand"] + d["ironRawElectricityDemand"] + d["ironPostPElectricityDemand"]\n\n    d["h2Demand"] = d["ironH2Demand"]\n\n    s["h2DistributeCapacity"] = d["h2Demand"]\n\n    d["h2DistributeDemand"] = calcDistributeDemand(s["h2DistributeCapacity"], d["h2Demand"])\n    d["h2BaseDemand"]= d["h2DistributeDemand"]\n    d["h2ProduceDemand"] = calcProduceDemand(settings["h2ProduceCapacity"], d["h2DistributeDemand"],0)\n    d["h2WaterDemand"] = calcProduceInputDemand(d["h2ProduceDemand"], settings["waterToH2"])\n    d["h2ElectricityDemand"] = calcProduceInputDemand(d["h2ProduceDemand"], settings["electricityToH2"])\n\n    d["waterDemand"] = d["h2WaterDemand"] + d["ironWaterDemand"]\n\n    s["waterDistributeCapacity"] = settings["h2ProduceCapacity"]*settings["waterToH2"] + settings["ironPrePProduceCapacity"]*settings["waterToIronPreP"] + settings["ironRawProduceCapacity"]*settings["waterToIronRaw"] + settings["ironPostPProduceCapacity"]*settings["waterToIronPostP"]\n\n    d["waterDistributeDemand"] = calcDistributeDemand(s["waterDistributeCapacity"], d["waterDemand"])\n    d["waterBaseDemand"] = d["waterDistributeDemand"]\n    d["waterBaseDemand"] = d["waterDistributeDemand"]\n    d["waterBaseDemand"] = d["waterDistributeDemand"]\n    d["waterProduceDemand"] = calcProduceDemand(settings["waterProduceCapacity"], d["waterDistributeDemand"], 0)\n    d["waterElectricityDemand"] = calcProduceInputDemand(d["waterProduceDemand"], settings["electricityToWater"])\n\n    d["electricityDemand"] = d["waterElectricityDemand"] + d["h2ElectricityDemand"] + d["ironElectricityDemand"]\n\n    s["electricityDistributeCapacity"] = settings["waterProduceCapacity"]*settings["electricityToWater"] + settings["h2ProduceCapacity"]*settings["electricityToH2"] + settings["ironPrePProduceCapacity"]*settings["electricityToIronPreP"] + settings["ironRawProduceCapacity"]*settings["electricityToIronRaw"] + settings["ironPostPProduceCapacity"]*settings["electricityToIronPostP"]\n\n    d["electricityDistributeDemand"] = calcDistributeDemand(s["electricityDistributeCapacity"], d["electricityDemand"])\n    d["electricityBaseDemand"] = d["electricityDistributeDemand"]\n\n    return s, d\n');__stickytape_write_module('model/functions.py',b'def calcDistributeDemand(\n    distributeCapacity, consumer1Demand=0, consumer2Demand=0, consumer3Demand=0\n):\n    return min(distributeCapacity, consumer1Demand + consumer2Demand + consumer3Demand)\n\n\ndef calcStoreDemand(storeCapacity, storeLevel, storeMaxChargeRate):\n    return min(storeCapacity - storeLevel, storeMaxChargeRate)\n\n\ndef calcProduceDemand(produceCapacity, distributeDemand, storeDemand):\n    return min(produceCapacity, distributeDemand + storeDemand)\n\n\ndef calcProduceInputDemand(produceDemand, inputToOutputFactor):\n    return produceDemand * inputToOutputFactor\n\n\ndef calcProduceOutput(\n    produceDemand,\n    input1Supply,\n    input1ToOutput1Factor,\n    input2Supply = 0,\n    input2ToOutput1Factor = 0,\n    input3Supply = 0,\n    input3ToOutput1Factor = 0,\n    input4Supply = 0,\n    input4ToOutput1Factor = 0\n):\n    a = 1000000\n    b = 1000000\n    c = 1000000\n    d = 1000000\n    \n    if input1ToOutput1Factor > 0:\n        a = input1Supply / input1ToOutput1Factor\n\n    if input2ToOutput1Factor > 0:\n        b = input2Supply / input2ToOutput1Factor\n\n    if input3ToOutput1Factor > 0:\n        c = input3Supply / input3ToOutput1Factor\n\n    if input4ToOutput1Factor > 0:\n        d = input4Supply / input4ToOutput1Factor\n    \n\n    return min(produceDemand, a, b, c, d)\n\n\ndef calcProduceInputSupply(upstreamDistributeOutput, produceInputDemand, reipDemand):\n    return upstreamDistributeOutput * (produceInputDemand / reipDemand)\n\n\ndef calcProduceInputUsed(\n    produceOutput,\n    produceInput1Supply,\n    input1ToOutput1Factor,\n    produceInput2Supply = 0,\n    input2ToOutput1Factor = 0,\n    produceInput3Supply = 0,\n    input3ToOutput1Factor = 0,\n    produceInput4Supply = 0,\n    input4ToOutput1Factor = 0,\n):\n    a = produceOutput * input1ToOutput1Factor\n    b = 1000000\n    c = 1000000\n    d = 1000000\n\n    if input2ToOutput1Factor > 0:\n        b = (produceInput2Supply / input2ToOutput1Factor) * input1ToOutput1Factor\n\n    if input3ToOutput1Factor > 0:\n        c = (produceInput3Supply / input3ToOutput1Factor) * input1ToOutput1Factor\n\n    if input4ToOutput1Factor > 0:\n        d = (produceInput4Supply / input4ToOutput1Factor) * input1ToOutput1Factor\n\n\n    return min(a, b, c, d)\n\n\ndef calcStoreChange(\n    storeCapacity, storeMaxChargeRate, storeLevel, distributeDemand, produceOutput\n):\n    if distributeDemand > produceOutput:\n        return -1 * min(\n            storeMaxChargeRate, storeLevel, distributeDemand - produceOutput\n        )\n    if distributeDemand < produceOutput:\n        return min(\n            storeMaxChargeRate,\n            produceOutput - distributeDemand,\n            storeCapacity - storeLevel,\n        )\n    return 0\n\n\ndef calcStoreLevelNew(storeLevel, storeChange):\n    return storeLevel + storeChange\n\n\ndef calcDistributeOutput(distributeDemand, produceOutput, storeChange):\n    if storeChange >= 0:\n        return min(\n            distributeDemand, produceOutput - storeChange\n        )\n    if storeChange < 0:\n        return min(\n            distributeDemand, produceOutput - storeChange\n        )\n    \n');__stickytape_write_module('model/sim_phase_1.py',b'from model.sim_ammonia import simAmmoniaSupply\nfrom model.sim_electricity import simElectricityRawRenewableSupply, simElectricitySupply\nfrom model.sim_fertiliser import simFertiliserSupply\nfrom model.sim_grid_export import simGridExportSupply\nfrom model.sim_hydrogen import simHydrogenSupply\nfrom model.sim_initial_demand import simInitialDemands\nfrom model.sim_iron import simIronSupply\nfrom model.sim_lohc import simLohcSupply\nfrom model.sim_mp1 import simMp1Supply\nfrom model.sim_water import simWaterSupply\nfrom model.sim_grid_export import simGridExportSupply\nfrom model.update_used_quantities import updateUsedQuantities\n\n\ndef simPhase1(i, s, settings):\n    simInitialDemands(i, s, settings)\n    simElectricityRawRenewableSupply(i, s, settings)\n    simElectricitySupply(i, s, settings)\n    simWaterSupply(i, s, settings)\n    simHydrogenSupply(i, s, settings)\n    #simLohcSupply(i, s, settings)\n    #simAmmoniaSupply(i, s, settings)\n    #simFertiliserSupply(i, s, settings)\n    simIronSupply(i, s, settings)\n    #simMp1Supply(i, s, settings)\n    #simGridExportSupply(i, s, settings)\n    updateUsedQuantities(i, s, settings)\n    return True\n');__stickytape_write_module('model/sim_ammonia.py',b'from model.functions import (\n    calcDistributeOutput,\n    calcProduceDemand,\n    calcProduceInputSupply,\n    calcProduceInputUsed,\n    calcProduceOutput,\n    calcStoreChange,\n    calcStoreDemand,\n)\n\n\ndef simAmmoniaSupply(i, s, settings):\n    s["nh3StoreLevel"] = s["nh3StoreLevelDict"][i]\n    s["nh3DownstreamElectricityReservation"] = (\n        s["mp1ElectricityDemand"]\n        + s["ironElectricityDemand"]\n        + s["fertElectricityDemand"]\n        + s["gridExportElectricityDemand"]\n    )\n    s["nh3UpstreamElectricityUsed"] = (\n        s["waterElectricityUsed"] + s["h2ElectricityUsed"] + s["lohcElectricityUsed"]\n    )\n    s["nh3ElectricitySupply"] = max(\n        0,\n        s["electricityDistributeOutput"]\n        - s["nh3DownstreamElectricityReservation"]\n        - s["nh3UpstreamElectricityUsed"],\n    )\n    s["nh3H2Supply"] = calcProduceInputSupply(\n        s["h2DistributeOutput"], s["nh3H2Demand"], s["h2Demand"]\n    )\n    s["nh3StoreDemand"] = calcStoreDemand(\n        settings["nh3StoreCapacity"],\n        s["nh3StoreLevel"],\n        settings["nh3StoreMaxChargeRate"],\n    )\n    s["nh3ProduceDemand"] = calcProduceDemand(\n        settings["nh3ProduceCapacity"], s["nh3DistributeDemand"], s["nh3StoreDemand"]\n    )\n    s["nh3ProduceOutput"] = calcProduceOutput(\n        s["nh3ProduceDemand"],\n        s["nh3H2Supply"],\n        settings["h2ToNh3"],\n        s["nh3ElectricitySupply"],\n        settings["electricityToNh3"]\n    )\n    s["nh3ElectricityUsed"] = calcProduceInputUsed(\n        s["nh3ProduceOutput"],\n        s["nh3ElectricitySupply"],\n        settings["electricityToNh3"],\n        s["nh3H2Supply"],\n        settings["h2ToNh3"]\n    )\n    s["nh3H2Used"] = calcProduceInputUsed(\n        s["nh3ProduceOutput"],\n        s["nh3H2Supply"],\n        settings["h2ToNh3"],\n        s["nh3ElectricitySupply"],\n        settings["electricityToNh3"]\n    )\n    s["nh3StoreChange"] = calcStoreChange(\n        settings["nh3StoreCapacity"],\n        settings["nh3StoreMaxChargeRate"],\n        s["nh3StoreLevel"],\n        s["nh3DistributeDemand"],\n        s["nh3ProduceOutput"],\n    )\n    s["nh3DistributeOutput"] = calcDistributeOutput(\n        s["nh3DistributeDemand"], s["nh3ProduceOutput"], s["nh3StoreChange"]\n    )\n    return True\n');__stickytape_write_module('model/sim_electricity.py',b'from model.functions import calcDistributeOutput, calcStoreChange\n\n\ndef simElectricityRawRenewableSupply(i, s, settings):\n    s["electricityRawSolarPvOutput"] = (\n        settings["solarPvCapacity"] * s["solarPvMwPerMwCapacity"][i]\n    )\n    s["electricityRawWindTurbinesOutput"] = (\n        settings["windTurbinesCapacity"] * s["windTurbinesMwPerMwCapacity"][i]\n    )\n    s["electricityRawRenewableOutput"] = (\n        s["electricityRawSolarPvOutput"] + s["electricityRawWindTurbinesOutput"]\n    )\n    return True\n\n\ndef simElectricitySupply(i, s, settings):\n    s["electricityStoreLevel"] = s["electricityStoreLevelDict"][i]\n    s["firmingAllowed"] = s["firmingAllowedDict"][i]\n    s["electricityStoreChange"] = calcStoreChange(\n        settings["electricityStoreCapacity"],\n        settings["electricityStoreMaxChargeRate"],\n        s["electricityStoreLevel"],\n        s["electricityDistributeDemand"],\n        s["electricityRawSolarPvOutput"] + s["electricityRawWindTurbinesOutput"]\n    )\n\n    s["electricityDistributeRenewableOutput"] = calcDistributeOutput(\n        s["electricityDistributeDemand"],\n        s["electricityRawRenewableOutput"],\n        s["electricityStoreChange"]\n    )\n    s["electricityDistributeRenewableOutput"] = calcDistributeOutput(\n        s["electricityDistributeDemand"],\n        min(\n            s["electricityRawRenewableOutput"],\n            settings["electricityBtmTransmissionCapacity"],\n        ),\n        s["electricityStoreChange"] \n    )\n\n    s["electricityProduceFirmingFull"] = s["firmingAllowed"] * max(\n        0, s["electricityDistributeDemand"] - s["electricityDistributeRenewableOutput"]\n    )\n\n    s["electricityProduceFirmingMinimum"] = max(0, -1 * s["firmingAllowed"] + 1) * (\n        s["waterElectricityDemand"] \n        + s["ironElectricityDemand"] \n    )\n    s["electricityProduceFirmingDemand"] = max(\n        s["electricityProduceFirmingFull"],\n        s["electricityProduceFirmingMinimum"]\n        - s["electricityDistributeRenewableOutput"],\n        0,\n    )\n    s["electricityProduceRenewableOutput"] = (\n        s["electricityDistributeRenewableOutput"] + s["electricityStoreChange"]\n    )\n\n    if s["electricityRawRenewableOutput"] > 0:\n        s["electricityProduceSolarPvOutput"] = s[\n            "electricityProduceRenewableOutput"\n        ] * (s["electricityRawSolarPvOutput"] / s["electricityRawRenewableOutput"])\n        s["electricityProduceWindTurbinesOutput"] = s[\n            "electricityProduceRenewableOutput"\n        ] * (s["electricityRawWindTurbinesOutput"] / s["electricityRawRenewableOutput"])\n    else:\n        s["electricityProduceSolarPvOutput"] = 0\n        s["electricityProduceWindTurbinesOutput"] = 0\n\n    s["electricityProduceFirmingOutput"] = min(\n        (settings["gridElectricityCapacity"] + settings["gasTurbinesCapacity"]),\n        s["electricityProduceFirmingDemand"],\n    )\n\n\n    s["electricityProduceGridOutput"] = min(\n        settings["gridElectricityCapacity"], s["electricityProduceFirmingOutput"]\n    )\n\n    s["wholesaleElectricityCost"] = s["electricityProduceGridOutput"] * s["wholesaleElectricityPrice"][i] \n\n    s["networkCharge"] = s["electricityProduceGridOutput"] * settings["electricityGridNetworkVariableCharge"]*1000 + s["networkHourlyStandingCharge"] + s["electricityGridKvaCharge"][i]\n\n    s["gridElectricityCost"] = s["wholesaleElectricityCost"] + s["networkCharge"]\n\n    s["electricityProduceGasTurbinesOutput"] = (\n        s["electricityProduceFirmingOutput"] - s["electricityProduceGridOutput"]\n    )\n\n    s["electricityProduceOutput"] = (\n        s["electricityProduceRenewableOutput"] + s["electricityProduceFirmingOutput"]\n    )\n    s["electricityDistributeOutput"] = calcDistributeOutput(\n        s["electricityDistributeDemand"],\n        s["electricityProduceOutput"],\n        s["electricityStoreChange"]\n    )\n\n    s["electricityProduceGridEmissions"] = (\n        s["electricityProduceGridOutput"] * s["gridElectricityEmissionsFactor"][i]\n    )\n    s["electricityProduceGasTurbinesEmissions"] = (\n        s["electricityProduceGasTurbinesOutput"] * settings["naturalGasToElectricity"]\n    ) / settings["naturalGasToEmissions"]\n    s["electricityProduceFirmingEmissions"] = (\n        s["electricityProduceGridEmissions"]\n        + s["electricityProduceGasTurbinesEmissions"]\n    )\n\n    s["electricityDistributeEmissions"] = s["electricityProduceFirmingEmissions"]\n    if s["electricityDistributeEmissions"] == 0:\n        s["electricityDistributeEmissionsIntensity"] = 0\n    if s["electricityDistributeOutput"] == 0:\n        s["electricityDistributeEmissionsIntensity"] = 0\n    else:\n        s["electricityDistributeEmissionsIntensity"] = (\n            s["electricityDistributeEmissions"] / s["electricityDistributeOutput"]\n        )\n    return True\n');__stickytape_write_module('model/sim_fertiliser.py',b'from model.functions import (\n    calcDistributeOutput,\n    calcProduceDemand,\n    calcProduceInputUsed,\n    calcProduceOutput,\n    calcStoreChange,\n    calcStoreDemand,\n)\n\n\ndef simFertiliserSupply(i, s, settings):\n    s["fertStoreLevel"] = s["fertStoreLevelDict"][i]\n    s["fertDownstreamElectricityReservation"] = (\n        s["mp1ElectricityDemand"] + s["ironElectricityDemand"] + s["gridExportElectricityDemand"]\n    )\n    s["fertUpstreamElectricityUsed"] = (\n        s["waterElectricityUsed"]\n        + s["h2ElectricityUsed"]\n        + s["lohcElectricityUsed"]\n        + s["nh3ElectricityUsed"]\n    )\n    s["fertElectricitySupply"] = max(\n        0,\n        s["electricityDistributeOutput"]\n        - s["nh3DownstreamElectricityReservation"]\n        - s["nh3UpstreamElectricityUsed"],\n    )\n    s["fertNh3Supply"] = min(\n        s["nh3DistributeOutput"], s["fertNh3Demand"]\n    )  # Different to other value chains - Fertiliser will consume as much Nh3 as can\n    s["fertStoreDemand"] = calcStoreDemand(\n        settings["fertStoreCapacity"],\n        s["fertStoreLevel"],\n        settings["fertStoreMaxChargeRate"],\n    )\n    s["fertProduceDemand"] = calcProduceDemand(\n        settings["fertProduceCapacity"], s["fertDistributeDemand"], s["fertStoreDemand"]\n    )\n    s["fertProduceOutput"] = calcProduceOutput(\n        s["fertProduceDemand"],\n        s["fertNh3Supply"],\n        settings["nh3ToFert"],\n        s["fertElectricitySupply"],\n        settings["electricityToFert"]\n    )\n    s["fertElectricityUsed"] = calcProduceInputUsed(\n        s["fertProduceOutput"],\n        s["fertElectricitySupply"],\n        settings["electricityToFert"],\n        s["fertNh3Supply"],\n        settings["nh3ToFert"]\n    )\n    s["fertNh3Used"] = calcProduceInputUsed(\n        s["fertProduceOutput"],\n        s["fertNh3Supply"],\n        settings["nh3ToFert"],\n        s["fertElectricitySupply"],\n        settings["electricityToFert"]\n    )\n    s["fertStoreChange"] = calcStoreChange(\n        settings["fertStoreCapacity"],\n        settings["fertStoreMaxChargeRate"],\n        s["fertStoreLevel"],\n        s["fertDistributeDemand"],\n        s["fertProduceOutput"],\n    )\n    s["fertDistributeOutput"] = calcDistributeOutput(\n        s["fertDistributeDemand"], s["fertProduceOutput"], s["fertStoreChange"]\n    )\n    return True\n');__stickytape_write_module('model/sim_grid_export.py',b'def simGridExportSupply(i, s, settings):\n\n    electricityUsedInReip = (\n        s["h2ElectricityUsed"]\n        + s["waterElectricityUsed"]\n    #    + s["lohcElectricityUsed"]\n    #    + s["nh3ElectricityUsed"]\n     #   + s["mp1ElectricityUsed"]\n        + s["ironElectricityUsed"]\n    #    + s["fertElectricityUsed"]\n    )\n\n    s["gridExportElectricityUsed"] = 0\n\n    if settings["electricityGridCurtailedExportToggle"]:\n        s["gridExportElectricityUsed"] = min(settings["gridElectricityCapacity"],\n                                            s["electricityDistributeCapacity"] - electricityUsedInReip,\n                                            s["electricityRawRenewableOutput"] - s["electricityProduceRenewableOutput"]\n                                            )\n    \n    if s["wholesaleElectricityPrice"][i] < 0:\n        s["gridExportElectricityUsed"] = 0\n\n    s["gridElectricityRevenue"] = s["gridExportElectricityUsed"] * s["wholesaleElectricityPrice"][i]\n\n    return True');__stickytape_write_module('model/sim_hydrogen.py',b'from model.functions import (\n    calcDistributeOutput,\n    calcProduceDemand,\n    calcProduceInputSupply,\n    calcProduceInputUsed,\n    calcProduceOutput,\n    calcStoreChange,\n    calcStoreDemand,\n)\n\n\ndef simHydrogenSupply(i, s, settings):\n    s["h2StoreLevel"] = s["h2StoreLevelDict"][i]\n    s["h2DownstreamElectricityReservation"] = (\n#        s["nh3ElectricityDemand"]\n#        + s["lohcElectricityDemand"]\n#        + s["mp1ElectricityDemand"]\n        + s["ironElectricityDemand"]\n#        + s["fertElectricityDemand"]\n        + s["gridExportElectricityDemand"]\n    )\n    s["h2UpstreamElectricityUsed"] = s["waterElectricityUsed"]\n    s["h2ElectricitySupply"] = max(\n        0,\n        s["electricityDistributeOutput"]\n        - s["h2DownstreamElectricityReservation"]\n        - s["h2UpstreamElectricityUsed"],\n    )\n    s["h2WaterSupply"] = calcProduceInputSupply(\n        s["waterDistributeOutput"], s["h2WaterDemand"], s["waterDistributeDemand"]\n    )\n    s["h2StoreDemand"] = calcStoreDemand(\n        settings["h2StoreCapacity"], s["h2StoreLevel"], settings["h2StoreMaxChargeRate"]\n    )\n\n    s["h2ProduceDemand"] = calcProduceDemand(\n        settings["h2ProduceCapacity"], s["h2DistributeDemand"], s["h2StoreDemand"]\n    )\n\n    if (s["electricityGridEconomicExport"] and settings["electricityGridCurtailedExportToggle"]):\n        s["h2ProduceDemand"] = 0\n\n    s["h2ProduceOutput"] = calcProduceOutput(\n        s["h2ProduceDemand"],\n        s["h2WaterSupply"],\n        settings["waterToH2"],\n        s["h2ElectricitySupply"],\n        settings["electricityToH2"]\n    )\n\n    s["h2ElectricityUsed"] = calcProduceInputUsed(\n        s["h2ProduceOutput"],\n        s["h2ElectricitySupply"],\n        settings["electricityToH2"],\n        s["h2WaterSupply"],\n        settings["waterToH2"]\n    )\n    s["h2WaterUsed"] = calcProduceInputUsed(\n        s["h2ProduceOutput"],\n        s["h2WaterSupply"],\n        settings["waterToH2"],\n        s["h2ElectricitySupply"],\n        settings["electricityToH2"]\n    )\n    s["h2StoreChange"] = calcStoreChange(\n        settings["h2StoreCapacity"],\n        settings["h2StoreMaxChargeRate"],\n        s["h2StoreLevel"],\n        s["h2DistributeDemand"],\n        s["h2ProduceOutput"],\n    )\n    s["h2DistributeOutput"] = calcDistributeOutput(\n        s["h2DistributeDemand"], s["h2ProduceOutput"], s["h2StoreChange"]\n    )\n    return True\n');__stickytape_write_module('model/sim_initial_demand.py',b'\nfrom model.functions import (\n    calcDistributeDemand,\n    calcProduceDemand,\n    calcProduceInputDemand,\n    calcStoreDemand,\n)\n\n# def electricityPriceCheck\n\ndef simInitialDemands(i, s, settings):\n\n\n    s["electricityGridEconomicExport"] = False\n    s["gridExportElectricityDemand"] = 0\n\n    if (s["wholesaleElectricityPrice"][i] > s["breakevenElectricityPrice"]) and (settings["electricityGridEconomicExportToggle"] == True):\n        s["electricityGridEconomicExport"] = True\n        s["gridExportElectricityDemand"] = settings["gridElectricityCapacity"]\n\n    if not settings["electricityGridCurtailedExportToggle"]:\n        s["gridExportElectricityDemand"] = 0\n\n#    s["mp1DistributeDemand"] = settings["mp1DistributeCapacity"]\n#    s["mp1StoreDemand"] = calcStoreDemand(\n#        settings["mp1StoreCapacity"],\n#        s["mp1StoreLevel"],\n#        settings["mp1StoreMaxChargeRate"],\n#    )\n#    s["mp1ProduceDemand"] = calcProduceDemand(\n#        settings["mp1ProduceCapacity"], s["mp1DistributeDemand"], s["mp1StoreDemand"]\n#    )\n#    s["mp1ElectricityDemand"] = calcProduceInputDemand(\n#        s["mp1ProduceDemand"], settings["electricityToMp1"]\n#    )\n    s["ironDistributeDemand"] = settings["ironDistributeCapacity"]\n    s["ironStoreDemand"] = calcStoreDemand(\n        settings["ironStoreCapacity"],\n        s["ironStoreLevel"],\n        settings["ironStoreMaxChargeRate"],\n    )\n    s["ironProduceDemand"] = calcProduceDemand(\n        settings["ironProduceCapacity"], s["ironDistributeDemand"], s["ironStoreDemand"]\n    )\n    s["ironPostPProduceDemand"] = s["ironProduceDemand"]\n    s["ironRawProduceDemand"] = s["ironPostPProduceDemand"] * settings["ironRawToIronPostP"]\n    s["ironPrePProduceDemand"] = s["ironRawProduceDemand"] * settings["ironPrePToIronRaw"]\n\n    s["ironPrePWaterDemand"] = calcProduceInputDemand(\n        s["ironPrePProduceDemand"], settings["waterToIronPreP"]\n    )                                              \n    s["ironRawWaterDemand"] = calcProduceInputDemand(\n        s["ironRawProduceDemand"], settings["waterToIronRaw"]\n    )\n    s["ironPostPWaterDemand"] = calcProduceInputDemand(\n        s["ironPostPProduceDemand"], settings["waterToIronPostP"]\n    )      \n    s["ironWaterDemand"] =  s["ironPrePWaterDemand"] + s["ironRawWaterDemand"] + s["ironPostPWaterDemand"] \n\n    s["ironPrePH2Demand"] = calcProduceInputDemand(\n        s["ironPrePProduceDemand"], settings["h2ToIronPreP"]\n    )                                              \n    s["ironRawH2Demand"] = calcProduceInputDemand(\n        s["ironRawProduceDemand"], settings["h2ToIronRaw"]\n    )\n    s["ironPostPH2Demand"] = calcProduceInputDemand(\n        s["ironPostPProduceDemand"], settings["h2ToIronPostP"]\n    )      \n    s["ironH2Demand"] =  s["ironPrePH2Demand"] + s["ironRawH2Demand"] + s["ironPostPH2Demand"]    \n\n    s["ironPrePElectricityDemand"] = calcProduceInputDemand(\n        s["ironPrePProduceDemand"], settings["electricityToIronPreP"]\n    )                                              \n    s["ironRawElectricityDemand"] = calcProduceInputDemand(\n        s["ironRawProduceDemand"], settings["electricityToIronRaw"]\n    )\n    s["ironPostPElectricityDemand"] = calcProduceInputDemand(\n        s["ironPostPProduceDemand"], settings["electricityToIronPostP"]\n    )      \n    s["ironElectricityDemand"] =  s["ironPrePElectricityDemand"] + s["ironRawElectricityDemand"] + s["ironPostPElectricityDemand"]    \n\n#    s["fertDistributeDemand"] = settings["fertDistributeCapacity"]\n#    s["fertStoreDemand"] = calcStoreDemand(\n#        settings["fertStoreCapacity"],\n#        s["fertStoreLevel"],\n#        settings["fertStoreMaxChargeRate"],\n#    )\n#    s["fertProduceDemand"] = calcProduceDemand(\n#        settings["fertProduceCapacity"], s["fertDistributeDemand"], s["fertStoreDemand"]\n#    )\n#    s["fertNh3Demand"] = calcProduceInputDemand(\n#        s["fertProduceDemand"], settings["nh3ToFert"]\n#    )\n#    s["fertElectricityDemand"] = calcProduceInputDemand(\n#        s["fertProduceDemand"], settings["electricityToFert"]\n#    )\n#    s["nh3DistributeDemand"] = settings["nh3DistributeCapacity"]\n#    s["nh3Demand"] = s["nh3DistributeDemand"]\n#    s["nh3StoreDemand"] = calcStoreDemand(\n#        settings["nh3StoreCapacity"],\n#        s["nh3StoreLevel"],\n#        settings["nh3StoreMaxChargeRate"],\n #   )\n#    s["nh3ProduceDemand"] = calcProduceDemand(\n#        settings["nh3ProduceCapacity"], s["nh3DistributeDemand"], s["nh3StoreDemand"]\n#    )\n#    s["nh3H2Demand"] = calcProduceInputDemand(\n    #     s["nh3ProduceDemand"], settings["h2ToNh3"]\n    # )\n    # s["nh3ElectricityDemand"] = calcProduceInputDemand(\n    #     s["nh3ProduceDemand"], settings["electricityToNh3"]\n    # )\n    # s["lohcDistributeDemand"] = settings["lohcDistributeCapacity"]\n    # s["lohcStoreDemand"] = calcStoreDemand(\n    #     settings["lohcStoreCapacity"],\n    #     s["lohcStoreLevel"],\n    #     settings["lohcStoreMaxChargeRate"],\n    # )\n    # s["lohcProduceDemand"] = calcProduceDemand(\n    #     settings["lohcProduceCapacity"], s["lohcDistributeDemand"], s["lohcStoreDemand"]\n    # )\n    # s["lohcH2Demand"] = calcProduceInputDemand(\n    #     s["lohcProduceDemand"], settings["h2ToLohc"]\n    # )\n    # s["lohcElectricityDemand"] = calcProduceInputDemand(\n    #     s["lohcProduceDemand"], settings["electricityToLohc"]\n    # )\n    s["h2Demand"] = s["ironH2Demand"] \n    #+ s["lohcH2Demand"]\n    #+ s["nh3H2Demand"]\n\n    s["h2DistributeDemand"] = calcDistributeDemand(s["h2DistributeCapacity"]\n        , s["h2Demand"]\n    )\n    s["h2StoreDemand"] = calcStoreDemand(\n        settings["h2StoreCapacity"], s["h2StoreLevel"], settings["h2StoreMaxChargeRate"]\n    )\n    s["h2ProduceDemand"] = calcProduceDemand(\n        settings["h2ProduceCapacity"], s["h2DistributeDemand"], s["h2StoreDemand"]\n    )\n\n    s["h2WaterDemand"] = calcProduceInputDemand(\n        s["h2ProduceDemand"], settings["waterToH2"]\n    )\n    s["h2ElectricityDemand"] = calcProduceInputDemand(\n        s["h2ProduceDemand"], settings["electricityToH2"]\n    )\n    s["waterDemand"] = s["h2WaterDemand"] + s["ironWaterDemand"]\n    s["waterDistributeDemand"] = calcDistributeDemand(\n        s["waterDistributeCapacity"], s["waterDemand"]\n    )\n    s["waterStoreDemand"] = calcStoreDemand(\n        settings["waterStoreCapacity"],\n        s["waterStoreLevel"],\n        settings["waterStoreMaxChargeRate"],\n    )\n    s["waterProduceDemand"] = calcProduceDemand(\n        settings["waterProduceCapacity"],\n        s["waterDistributeDemand"],\n        s["waterStoreDemand"],\n    )\n    s["waterElectricityDemand"] = calcProduceInputDemand(\n        s["waterProduceDemand"], settings["electricityToWater"]\n    )\n    s["electricityDemand"] = (\n        s["waterElectricityDemand"]\n        + s["h2ElectricityDemand"]\n#        + s["mp1ElectricityDemand"]\n#        + s["nh3ElectricityDemand"]\n#        + s["lohcElectricityDemand"]\n        + s["ironElectricityDemand"]\n#        + s["fertElectricityDemand"]\n        + s["gridExportElectricityDemand"]\n    )\n    s["electricityDistributeDemand"] = calcDistributeDemand(\n        s["electricityDistributeCapacity"], s["electricityDemand"]\n    )\n\n    s["gridExportElectricityUsed"] = 0\n\n    return True\n');__stickytape_write_module('model/sim_iron.py',b'from model.functions import (\n    calcDistributeOutput,\n    calcProduceDemand,\n    calcProduceInputSupply,\n    calcProduceInputUsed,\n    calcProduceOutput,\n    calcStoreChange,\n    calcStoreDemand,\n)\n\n\ndef simIronSupply(i, s, settings):\n    s["ironStoreLevel"] = s["ironStoreLevelDict"][i]\n    s["ironDownstreamElectricityReservation"] =  s["gridExportElectricityDemand"] \n    # + s["mp1ElectricityDemand"]\n    s["ironUpstreamElectricityUsed"] = (\n        s["waterElectricityUsed"]\n        + s["h2ElectricityUsed"]\n    #    + s["lohcElectricityUsed"]\n    #    + s["nh3ElectricityUsed"]\n    #    + s["fertElectricityUsed"]\n    )\n\n#---------\n\n    s["ironProduceDemand"] = calcProduceDemand(\n        settings["ironProduceCapacity"], s["ironDistributeDemand"], s["ironStoreDemand"]\n    )\n\n    s["ironPostPProduceDemand"] = s["ironProduceDemand"]\n    s["ironRawProduceDemand"] = s["ironPostPProduceDemand"] * settings["ironRawToIronPostP"]\n    s["ironPrePProduceDemand"] = s["ironRawProduceDemand"] * settings["ironPrePToIronRaw"]\n\n    s["ironElectricitySupply"] = max(\n        0,\n        s["electricityDistributeOutput"]\n        - s["ironDownstreamElectricityReservation"]\n        - s["ironUpstreamElectricityUsed"],\n    )\n    \n    s["ironPrePElectricitySupply"] = s["ironElectricitySupply"] * (s["ironPrePProduceDemand"]*settings["electricityToIronPreP"]  / (s["ironProduceDemand"]*(settings["electricityToIronPreP"] + settings["electricityToIronRaw"] + settings["electricityToIronPostP"])))\n\n    s["ironPrePH2Supply"] = calcProduceInputSupply(\n        s["h2DistributeOutput"], s["ironPrePH2Demand"], s["h2DistributeDemand"]\n    )\n    s["ironPrePWaterSupply"] = calcProduceInputSupply(\n        s["waterDistributeOutput"], s["ironPrePWaterDemand"], s["waterDistributeDemand"]\n    )\n\n    s["ironPrePProduceOutput"] = calcProduceOutput(\n        s["ironPrePProduceDemand"],\n        s["ironPrePH2Supply"],\n        settings["h2ToIronPreP"],\n        s["ironPrePElectricitySupply"],\n        settings["electricityToIronPreP"],\n        s["ironPrePWaterSupply"],\n        settings["waterToIronPreP"],\n    )\n\n    s["ironPrePElectricityUsed"] = calcProduceInputUsed(\n        s["ironPrePProduceOutput"],\n        s["ironPrePElectricitySupply"],\n        settings["electricityToIronPreP"],\n        s["ironPrePH2Supply"],\n        settings["h2ToIronPreP"],\n        s["ironPrePWaterSupply"],\n        settings["waterToIronPreP"],\n    )\n    s["ironPrePH2Used"] = calcProduceInputUsed(\n        s["ironPrePProduceOutput"],\n        s["ironPrePH2Supply"],\n        settings["h2ToIronPreP"],\n        s["ironPrePElectricitySupply"],\n        settings["electricityToIronPreP"],\n        s["ironPrePWaterSupply"],\n        settings["waterToIronPreP"],\n    )\n    s["ironPrePWaterUsed"] = calcProduceInputUsed(\n        s["ironPrePProduceOutput"],\n        s["ironPrePWaterSupply"],\n        settings["waterToIronPreP"],\n        s["ironPrePH2Supply"],\n        settings["h2ToIronPreP"],\n        s["ironPrePElectricitySupply"],\n        settings["electricityToIronPreP"],\n    )\n\n#---------\n\n     \n    s["ironRawElectricitySupply"] = s["ironElectricitySupply"] * (s["ironRawProduceDemand"]*settings["electricityToIronRaw"]  / (s["ironProduceDemand"]*(settings["electricityToIronPreP"] + settings["electricityToIronRaw"] + settings["electricityToIronPostP"])))\n\n\n    s["ironRawH2Supply"] = calcProduceInputSupply(\n        s["h2DistributeOutput"], s["ironRawH2Demand"], s["h2DistributeDemand"]\n    )\n    s["ironRawWaterSupply"] = calcProduceInputSupply(\n        s["waterDistributeOutput"], s["ironRawWaterDemand"], s["waterDistributeDemand"]\n    )\n\n    s["ironRawProduceOutput"] = calcProduceOutput(\n        s["ironRawProduceDemand"],\n        s["ironRawH2Supply"],\n        settings["h2ToIronRaw"],\n        s["ironRawElectricitySupply"],\n        settings["electricityToIronRaw"],\n        s["ironRawWaterSupply"],\n        settings["waterToIronRaw"],\n        s["ironPrePProduceOutput"],\n        settings["ironPrePToIronRaw"]\n    )\n\n    s["ironRawElectricityUsed"] = calcProduceInputUsed(\n        s["ironRawProduceOutput"],\n        s["ironRawElectricitySupply"],\n        settings["electricityToIronRaw"],\n        s["ironRawH2Supply"],\n        settings["h2ToIronRaw"],\n        s["ironRawWaterSupply"],\n        settings["waterToIronRaw"],\n    )\n    s["ironRawH2Used"] = calcProduceInputUsed(\n        s["ironRawProduceOutput"],\n        s["ironRawH2Supply"],\n        settings["h2ToIronRaw"],\n        s["ironRawElectricitySupply"],\n        settings["electricityToIronRaw"],\n        s["ironRawWaterSupply"],\n        settings["waterToIronRaw"],\n    )\n    s["ironRawWaterUsed"] = calcProduceInputUsed(\n        s["ironRawProduceOutput"],\n        s["ironRawWaterSupply"],\n        settings["waterToIronRaw"],\n        s["ironRawH2Supply"],\n        settings["h2ToIronRaw"],\n        s["ironRawElectricitySupply"],\n        settings["electricityToIronRaw"],\n    )\n\n#---------\n\n    \n    s["ironPostPElectricitySupply"] = s["ironElectricitySupply"] * (s["ironPostPProduceDemand"]*settings["electricityToIronPostP"]  / (s["ironProduceDemand"]*(settings["electricityToIronPreP"] + settings["electricityToIronRaw"] + settings["electricityToIronPostP"])))\n\n    s["ironPostPH2Supply"] = calcProduceInputSupply(\n        s["h2DistributeOutput"], s["ironPostPH2Demand"], s["h2DistributeDemand"]\n    )\n    s["ironPostPWaterSupply"] = calcProduceInputSupply(\n        s["waterDistributeOutput"], s["ironPostPWaterDemand"], s["waterDistributeDemand"]\n    )\n\n    s["ironPostPProduceOutput"] = calcProduceOutput(\n        s["ironPostPProduceDemand"],\n        s["ironPostPH2Supply"],\n        settings["h2ToIronPostP"],\n        s["ironPostPElectricitySupply"],\n        settings["electricityToIronPostP"],\n        s["ironPostPWaterSupply"],\n        settings["waterToIronPostP"],\n        s["ironRawProduceOutput"],\n        settings["ironRawToIronPostP"]\n    )\n\n    s["ironPostPElectricityUsed"] = calcProduceInputUsed(\n        s["ironPostPProduceOutput"],\n        s["ironPostPElectricitySupply"],\n        settings["electricityToIronPostP"],\n        s["ironPostPH2Supply"],\n        settings["h2ToIronPostP"],\n        s["ironPostPWaterSupply"],\n        settings["waterToIronPostP"],\n    )\n    s["ironPostPH2Used"] = calcProduceInputUsed(\n        s["ironPostPProduceOutput"],\n        s["ironPostPH2Supply"],\n        settings["h2ToIronPostP"],\n        s["ironPostPElectricitySupply"],\n        settings["electricityToIronPostP"],\n        s["ironPostPWaterSupply"],\n        settings["waterToIronPostP"],\n    )\n    s["ironPostPWaterUsed"] = calcProduceInputUsed(\n        s["ironPostPProduceOutput"],\n        s["ironPostPWaterSupply"],\n        settings["waterToIronPostP"],\n        s["ironPostPH2Supply"],\n        settings["h2ToIronPostP"],\n        s["ironPostPElectricitySupply"],\n        settings["electricityToIronPostP"],\n    )\n\n#--------\n\n    s["ironH2Supply"] = s["ironPrePH2Supply"] + s["ironRawH2Supply"] + s["ironPostPH2Supply"] \n    \n    s["ironWaterSupply"] = s["ironPrePWaterSupply"] + s["ironRawWaterSupply"] + s["ironPostPWaterSupply"] \n\n    s["ironProduceOutput"] = s["ironPostPProduceOutput"]\n\n    s["ironElectricityUsed"] = s["ironPrePElectricityUsed"] + s["ironRawElectricityUsed"] + s["ironPostPElectricityUsed"]\n\n    s["ironH2Used"] = s["ironPrePH2Used"] + s["ironRawH2Used"] + s["ironPostPH2Used"]   \n\n    s["ironWaterUsed"] = s["ironPrePWaterUsed"] + s["ironRawWaterUsed"] + s["ironPostPWaterUsed"]\n\n    \n    s["ironStoreChange"] = calcStoreChange(\n        settings["ironStoreCapacity"],\n        settings["ironStoreMaxChargeRate"],\n        s["ironStoreLevel"],\n        s["ironDistributeDemand"],\n        s["ironProduceOutput"],\n    )\n    s["ironDistributeOutput"] = calcDistributeOutput(\n        s["ironDistributeDemand"], s["ironProduceOutput"], s["ironStoreChange"]\n    )\n    return True\n');__stickytape_write_module('model/sim_lohc.py',b'from model.functions import (\n    calcDistributeOutput,\n    calcProduceDemand,\n    calcProduceInputSupply,\n    calcProduceInputUsed,\n    calcProduceOutput,\n    calcStoreChange,\n    calcStoreDemand,\n)\n\n\ndef simLohcSupply(i, s, settings):\n    s["lohcStoreLevel"] = s["lohcStoreLevelDict"][i]\n    s["lohcDownstreamElectricityReservation"] = (\n        s["nh3ElectricityDemand"]\n        + s["mp1ElectricityDemand"]\n        + s["ironElectricityDemand"]\n        + s["fertElectricityDemand"]\n        + s["gridExportElectricityDemand"]\n    )\n    s["lohcUpstreamElectricityUsed"] = (\n        s["waterElectricityUsed"] + s["h2ElectricityUsed"]\n    )\n    s["lohcElectricitySupply"] = max(\n        0,\n        s["electricityDistributeOutput"]\n        - s["lohcDownstreamElectricityReservation"]\n        - s["lohcUpstreamElectricityUsed"],\n    )\n    s["lohcH2Supply"] = calcProduceInputSupply(\n        s["h2DistributeOutput"], s["lohcH2Demand"], s["h2Demand"]\n    )\n    s["lohcStoreDemand"] = calcStoreDemand(\n        settings["lohcStoreCapacity"],\n        s["lohcStoreLevel"],\n        settings["lohcStoreMaxChargeRate"],\n    )\n    s["lohcProduceDemand"] = calcProduceDemand(\n        settings["lohcProduceCapacity"], s["lohcDistributeDemand"], s["lohcStoreDemand"]\n    )\n    s["lohcProduceOutput"] = calcProduceOutput(\n        s["lohcProduceDemand"],\n        s["lohcH2Supply"],\n        settings["h2ToLohc"],\n        s["lohcElectricitySupply"],\n        settings["electricityToLohc"]\n    )\n    s["lohcElectricityUsed"] = calcProduceInputUsed(\n        s["lohcProduceOutput"],\n        s["lohcElectricitySupply"],\n        settings["electricityToLohc"],\n        s["lohcH2Supply"],\n        settings["h2ToLohc"]\n    )\n    s["lohcH2Used"] = calcProduceInputUsed(\n        s["lohcProduceOutput"],\n        s["lohcH2Supply"],\n        settings["h2ToLohc"],\n        s["lohcElectricitySupply"],\n        settings["electricityToLohc"]\n    )\n    s["lohcStoreChange"] = calcStoreChange(\n        settings["lohcStoreCapacity"],\n        settings["lohcStoreMaxChargeRate"],\n        s["lohcStoreLevel"],\n        s["lohcDistributeDemand"],\n        s["lohcProduceOutput"],\n    )\n    s["lohcDistributeOutput"] = calcDistributeOutput(\n        s["lohcDistributeDemand"], s["lohcProduceOutput"], s["lohcStoreChange"]\n    )\n    return True\n');__stickytape_write_module('model/sim_mp1.py',b'from model.functions import (\n    calcDistributeOutput,\n    calcProduceDemand,\n    calcProduceInputUsed,\n    calcProduceOutput,\n    calcStoreChange,\n    calcStoreDemand,\n)\n\n\ndef simMp1Supply(i, s, settings):\n    s["mp1StoreLevel"] = s["mp1StoreLevelDict"][i]\n    s["mp1DownstreamElectricityReservation"] = + s["gridExportElectricityDemand"]\n    s["mp1UpstreamElectricityUsed"] = (\n        s["waterElectricityUsed"]\n        + s["h2ElectricityUsed"]\n        + s["lohcElectricityUsed"]\n        + s["nh3ElectricityUsed"]\n        + s["fertElectricityUsed"]\n        + s["ironElectricityUsed"]\n    )\n    s["mp1ElectricitySupply"] = max(\n        0,\n        s["electricityDistributeOutput"]\n        - s["mp1DownstreamElectricityReservation"]\n        - s["mp1UpstreamElectricityUsed"],\n    )\n    s["mp1StoreDemand"] = calcStoreDemand(\n        settings["mp1StoreCapacity"],\n        s["mp1StoreLevel"],\n        settings["mp1StoreMaxChargeRate"],\n    )\n    s["mp1ProduceDemand"] = calcProduceDemand(\n        settings["mp1ProduceCapacity"], s["mp1DistributeDemand"], s["mp1StoreDemand"]\n    )\n    s["mp1ProduceOutput"] = calcProduceOutput(\n        s["mp1ProduceDemand"],\n        s["mp1ElectricitySupply"],\n        settings["electricityToMp1"]\n    )\n    s["mp1ElectricityUsed"] = calcProduceInputUsed(\n        s["mp1ProduceOutput"],\n        s["mp1ElectricitySupply"],\n        settings["electricityToMp1"]\n    )\n    s["mp1StoreChange"] = calcStoreChange(\n        settings["mp1StoreCapacity"],\n        settings["mp1StoreMaxChargeRate"],\n        s["mp1StoreLevel"],\n        s["mp1DistributeDemand"],\n        s["mp1ProduceOutput"],\n    )\n    s["mp1DistributeOutput"] = calcDistributeOutput(\n        s["mp1DistributeDemand"], s["mp1ProduceOutput"], s["mp1StoreChange"]\n    )\n    return True\n');__stickytape_write_module('model/sim_water.py',b'from model.functions import (\n    calcDistributeOutput,\n    calcProduceDemand,\n    calcProduceInputUsed,\n    calcProduceOutput,\n    calcStoreChange,\n    calcStoreDemand,\n)\n\n\ndef simWaterSupply(i, s, settings):\n    s["waterStoreLevel"] = s["waterStoreLevelDict"][i]\n    s["waterElectricitySupply"] = min(\n        s["electricityDistributeOutput"], s["waterElectricityDemand"]\n    )\n    s["waterStoreDemand"] = calcStoreDemand(\n        settings["waterStoreCapacity"],\n        s["waterStoreLevel"],\n        settings["waterStoreMaxChargeRate"],\n    )\n    s["waterProduceDemand"] = calcProduceDemand(\n        settings["waterProduceCapacity"],\n        s["waterDistributeDemand"],\n        s["waterStoreDemand"],\n    )\n    s["waterProduceOutput"] = calcProduceOutput(\n        s["waterProduceDemand"],\n        s["waterElectricitySupply"],\n        settings["electricityToWater"]\n    )\n    s["waterElectricityUsed"] = calcProduceInputUsed(\n        s["waterProduceOutput"],\n        s["waterElectricitySupply"],\n        settings["electricityToWater"]\n    )\n    s["waterStoreChange"] = calcStoreChange(\n        settings["waterStoreCapacity"],\n        settings["waterStoreMaxChargeRate"],\n        s["waterStoreLevel"],\n        s["waterDistributeDemand"],\n        s["waterProduceOutput"],\n    )\n    s["waterDistributeOutput"] = calcDistributeOutput(\n        s["waterDistributeDemand"], s["waterProduceOutput"], s["waterStoreChange"]\n    )\n    return True\n');__stickytape_write_module('model/update_used_quantities.py',b'def updateUsedQuantities(i, s, settings):\n    s["waterUsed"] = s["h2WaterUsed"] + s["ironWaterUsed"]\n    s["electricityUsed"] = (\n        s["h2ElectricityUsed"]\n        + s["waterElectricityUsed"]\n       # + s["lohcElectricityUsed"]\n       # + s["nh3ElectricityUsed"]\n       # + s["mp1ElectricityUsed"]\n        + s["ironElectricityUsed"]\n       # + s["fertElectricityUsed"]\n        + s["gridExportElectricityUsed"]\n    )\n\n    s["h2Used"] = s["ironH2Used"]\n    # s["lohcH2Used"]\n    #+ s["nh3H2Used"] \n     \n    #s["nh3Used"] = s["nh3DistributeOutput"]\n    s["electricityDistributeOutput"] = s["electricityDistributeOutput"] + s["gridExportElectricityUsed"]\n    return True\n');__stickytape_write_module('model/sim_phase_2.py',b'from model.sim_ammonia import simAmmoniaSupply\nfrom model.sim_electricity import simElectricitySupply\nfrom model.sim_fertiliser import simFertiliserSupply\nfrom model.sim_hydrogen import simHydrogenSupply\nfrom model.sim_iron import simIronSupply\nfrom model.sim_lohc import simLohcSupply\nfrom model.sim_mp1 import simMp1Supply\nfrom model.sim_water import simWaterSupply\nfrom model.sim_grid_export import simGridExportSupply\nfrom model.update_demands import updateDemands\nfrom model.update_used_quantities import updateUsedQuantities\n\n\n\ndef simPhase2(i, s, settings):\n    updateDemands(i, s, settings)\n    simElectricitySupply(i, s, settings)\n    simWaterSupply(i, s, settings)\n    simHydrogenSupply(i, s, settings)\n   # simLohcSupply(i, s, settings)\n    #simAmmoniaSupply(i, s, settings)\n    #simFertiliserSupply(i, s, settings)\n    simIronSupply(i, s, settings)\n    #simMp1Supply(i, s, settings)\n    #simGridExportSupply(i, s, settings)\n    updateUsedQuantities(i, s, settings)\n    return True\n');__stickytape_write_module('model/update_demands.py',b'\nfrom model.functions import calcDistributeDemand\n\n\ndef updateDemands(i, s, settings):\n    \n    s["waterElectricityDemand"] = s["waterElectricityUsed"] + 0.0001\n    s["h2ElectricityDemand"] = s["h2ElectricityUsed"] + 0.0001\n    #s["lohcElectricityDemand"] = s["lohcElectricityUsed"] + 0.0001\n    #s["nh3ElectricityDemand"] = s["nh3ElectricityUsed"] + 0.0001\n #   s["mp1ElectricityDemand"] = s["mp1ElectricityUsed"] + 0.0001\n    s["ironElectricityDemand"] = s["ironElectricityUsed"] + 0.0001\n    #s["fertElectricityDemand"] = s["fertElectricityUsed"] + 0.0001\n    s["gridExportElectricityDemand"] = s["gridExportElectricityUsed"] + 0.0001\n\n    s["h2WaterDemand"] = s["h2WaterUsed"] + 0.0001\n    s["ironWaterDemand"] = s["ironWaterUsed"] + 0.0001\n\n    #s["lohcH2Demand"] = s["lohcH2Used"] + 0.0001\n    #s["nh3H2Demand"] = s["nh3H2Used"] + 0.0001\n    s["ironH2Demand"] = s["ironH2Used"] + 0.0001\n\n    #s["fertNh3Demand"] = s["fertNh3Used"] + 0.0001\n\n    s["electricityDemand"] = (\n        s["waterElectricityDemand"]\n        + s["h2ElectricityDemand"]\n    #    + s["lohcElectricityDemand"]\n    #    + s["nh3ElectricityDemand"]\n    #    + s["mp1ElectricityDemand"]\n        + s["ironElectricityDemand"]\n    #    + s["fertElectricityDemand"]\n        + s["gridExportElectricityDemand"]\n    )\n\n    s["electricityDistributeDemand"] = calcDistributeDemand(\n        s["electricityDistributeCapacity"], s["electricityDemand"]\n    )\n\n    s["waterDemand"] = s["h2WaterDemand"] + s["ironWaterDemand"]\n    s["waterDistributeDemand"] = s["waterDemand"]\n\n    s["h2Demand"] = s["ironH2Demand"]\n    #+ s["lohcH2Demand"] \n    #+ s["nh3H2Demand"] \n     \n    s["h2DistributeDemand"] = s["h2Demand"]\n\n    s["ironPrePH2Demand"] = s["ironPrePH2Used"] + 0.0001\n    s["ironRawH2Demand"] = s["ironRawH2Used"] + 0.0001\n    s["ironPostPH2Demand"] = s["ironPostPH2Used"] + 0.0001    \n\n    s["ironPrePWaterDemand"] = s["ironPrePWaterUsed"] + 0.0001\n    s["ironRawWaterDemand"] = s["ironRawWaterUsed"] + 0.0001\n    s["ironPostPWaterDemand"] = s["ironPostPWaterUsed"] + 0.0001    \n\n    return True\n');__stickytape_write_module('model/sim_phase_3.py',b'from model.sim_ammonia import simAmmoniaSupply\nfrom model.sim_electricity import simElectricitySupply\nfrom model.sim_fertiliser import simFertiliserSupply\nfrom model.sim_hydrogen import simHydrogenSupply\nfrom model.sim_iron import simIronSupply\nfrom model.sim_lohc import simLohcSupply\nfrom model.sim_mp1 import simMp1Supply\nfrom model.sim_water import simWaterSupply\nfrom model.sim_grid_export import simGridExportSupply\nfrom model.update_demands import updateDemands\nfrom model.update_used_quantities import updateUsedQuantities\n\n\ndef simPhase3(i, s, settings):\n    updateDemands(i, s, settings)\n    simElectricitySupply(i, s, settings)\n    simWaterSupply(i, s, settings)\n    simHydrogenSupply(i, s, settings)\n    #simLohcSupply(i, s, settings)\n    #simAmmoniaSupply(i, s, settings)\n    #simFertiliserSupply(i, s, settings)\n    simIronSupply(i, s, settings)\n    #simMp1Supply(i, s, settings)\n    #simGridExportSupply(i, s, settings)\n    updateUsedQuantities(i, s, settings)\n    return True\n');__stickytape_write_module('model/sim_phase_4.py',b'from model.sim_ammonia import simAmmoniaSupply\nfrom model.sim_electricity import simElectricitySupply\nfrom model.sim_fertiliser import simFertiliserSupply\nfrom model.sim_hydrogen import simHydrogenSupply\nfrom model.sim_iron import simIronSupply\nfrom model.sim_lohc import simLohcSupply\nfrom model.sim_mp1 import simMp1Supply\nfrom model.sim_water import simWaterSupply\nfrom model.sim_grid_export import simGridExportSupply\nfrom model.update_demands import updateDemands\nfrom model.update_used_quantities import updateUsedQuantities\n\n\ndef simPhase4(i, s, settings):\n    updateDemands(i, s, settings)\n    simElectricitySupply(i, s, settings)\n    simWaterSupply(i, s, settings)\n    simHydrogenSupply(i, s, settings)\n    #simLohcSupply(i, s, settings)\n    #simAmmoniaSupply(i, s, settings)\n    #simFertiliserSupply(i, s, settings)\n    simIronSupply(i, s, settings)\n    #simMp1Supply(i, s, settings)\n    simGridExportSupply(i, s, settings)\n    updateUsedQuantities(i, s, settings)\n    return True\n');__stickytape_write_module('model/track_metrics.py',b'def trackMetrics(i, s):\n    s["networkChargeDict"][i] = s["networkCharge"]\n    s["wholesaleElectricityCostDict"][i] = s["wholesaleElectricityCost"]\n    s["electricityDistributeDemandDict"][i] = s["electricityDistributeDemand"]\n    s["electricityDistributeOutputDict"][i] = s["electricityDistributeOutput"]\n    s["electricityDistributeRenewableOutputDict"][i] = s[\n        "electricityDistributeRenewableOutput"\n    ]\n    s["electricityProduceGridEmissionsDict"][i] = s["electricityProduceGridEmissions"]\n    s["electricityProduceGridOutputDict"][i] = s["electricityProduceGridOutput"]\n    s["electricityProduceGasTurbinesEmissionsDict"][i] = s[\n        "electricityProduceGasTurbinesEmissions"\n    ]\n    s["electricityProduceGasTurbinesOutputDict"][i] = s[\n        "electricityProduceGasTurbinesOutput"\n    ]\n    s["electricityProduceFirmingEmissionsDict"][i] = s[\n        "electricityProduceFirmingEmissions"\n    ]\n    s["electricityProduceFirmingOutputDict"][i] = s["electricityProduceFirmingOutput"]\n    s["electricityProduceRenewableOutputDict"][i] = s[\n        "electricityProduceRenewableOutput"\n    ]\n    s["electricityProduceFirmingDemandDict"][i] = s["electricityProduceFirmingDemand"]\n    s["electricityProduceFirmingFullDict"][i] = s["electricityProduceFirmingFull"]\n    s["electricityProduceFirmingMinimumDict"][i] = s["electricityProduceFirmingMinimum"]\n    s["firmingAllowedDict"][i] = s["firmingAllowed"]\n    \n    s["electricityProduceOutputDict"][i] = s["electricityProduceOutput"]\n    s["electricityProduceSolarPvOutputDict"][i] = s["electricityProduceSolarPvOutput"]\n    s["electricityProduceWindTurbinesOutputDict"][i] = s[\n        "electricityProduceWindTurbinesOutput"\n    ]\n    s["electricityRawRenewableOutputDict"][i] = s["electricityRawRenewableOutput"]\n    s["electricityRawSolarPvOutputDict"][i] = s["electricityRawSolarPvOutput"]\n    s["electricityRawWindTurbinesOutputDict"][i] = s["electricityRawWindTurbinesOutput"]\n    s["electricityUsedDict"][i] = s["electricityUsed"]\n\n    s["waterDistributeDemandDict"][i] = s["waterDistributeDemand"]\n    s["waterDistributeOutputDict"][i] = s["waterDistributeOutput"]\n    s["waterElectricityDemandDict"][i] = s["waterElectricityDemand"]\n    s["waterElectricityUsedDict"][i] = s["waterElectricityUsed"]\n    s["waterProduceOutputDict"][i] = s["waterProduceOutput"]\n    s["waterUsedDict"][i] = s["waterUsed"]\n\n    s["h2DistributeDemandDict"][i] = s["h2DistributeDemand"]\n    s["h2DistributeOutputDict"][i] = s["h2DistributeOutput"]\n    s["h2ElectricityDemandDict"][i] = s["h2ElectricityDemand"]\n    s["h2ElectricityUsedDict"][i] = s["h2ElectricityUsed"]\n    s["h2ProduceOutputDict"][i] = s["h2ProduceOutput"]\n    s["h2UsedDict"][i] = s["h2Used"]\n    s["h2WaterUsedDict"][i] = s["h2WaterUsed"]\n\n #   s["lohcDistributeDemandDict"][i] = s["lohcDistributeDemand"]\n #   s["lohcDistributeOutputDict"][i] = s["lohcDistributeOutput"]\n #   s["lohcElectricityDemandDict"][i] = s["lohcElectricityDemand"]\n #   s["lohcElectricityUsedDict"][i] = s["lohcElectricityUsed"]\n #   s["lohcH2DemandDict"][i] = s["lohcH2Demand"]\n #   s["lohcH2UsedDict"][i] = s["lohcH2Used"]\n #   s["lohcProduceOutputDict"][i] = s["lohcProduceOutput"]\n\n  #  s["nh3DistributeDemandDict"][i] = s["nh3DistributeDemand"]\n  #  s["nh3DistributeOutputDict"][i] = s["nh3DistributeOutput"]\n  #  s["nh3ElectricityDemandDict"][i] = s["nh3ElectricityDemand"]\n  #  s["nh3ElectricityUsedDict"][i] = s["nh3ElectricityUsed"]\n  #  s["nh3H2DemandDict"][i] = s["nh3H2Demand"]\n  #  s["nh3H2UsedDict"][i] = s["nh3H2Used"]\n  #  s["nh3ProduceOutputDict"][i] = s["nh3ProduceOutput"]\n\n  #  s["fertDistributeDemandDict"][i] = s["fertDistributeDemand"]\n  #  s["fertDistributeOutputDict"][i] = s["fertDistributeOutput"]\n  #  s["fertElectricityDemandDict"][i] = s["fertElectricityDemand"]\n  #  s["fertElectricityUsedDict"][i] = s["fertElectricityUsed"]\n  #  s["fertNh3DemandDict"][i] = s["fertNh3Demand"]\n  #  s["fertNh3UsedDict"][i] = s["fertNh3Used"]\n  #  s["fertProduceOutputDict"][i] = s["fertProduceOutput"]\n\n  #  s["mp1DistributeDemandDict"][i] = s["mp1DistributeDemand"]\n  #  s["mp1DistributeOutputDict"][i] = s["mp1DistributeOutput"]\n  #  s["mp1ElectricityDemandDict"][i] = s["mp1ElectricityDemand"]\n  #  s["mp1ElectricityUsedDict"][i] = s["mp1ElectricityUsed"]\n  #  s["mp1ProduceOutputDict"][i] = s["mp1ProduceOutput"]\n\n    s["ironDistributeDemandDict"][i] = s["ironDistributeDemand"]\n    s["ironDistributeOutputDict"][i] = s["ironDistributeOutput"]\n    s["ironElectricityDemandDict"][i] = s["ironElectricityDemand"]\n    s["ironElectricityUsedDict"][i] = s["ironElectricityUsed"]\n    s["ironWaterUsedDict"][i] = s["ironWaterUsed"]\n    s["ironEmissionsIntensityYtdDict"][i] = s["ironEmissionsIntensityYtd"]\n    s["ironH2UsedDict"][i] = s["ironH2Used"]\n    s["ironProduceOutputDict"][i] = s["ironProduceOutput"]\n\n    s["ironPrePElectricityDemandDict"][i] = s["ironPrePElectricityDemand"]\n    s["ironPrePElectricityUsedDict"][i] = s["ironPrePElectricityUsed"]\n    s["ironPrePWaterUsedDict"][i] = s["ironPrePWaterUsed"]\n    s["ironPrePH2UsedDict"][i] = s["ironPrePH2Used"]\n    s["ironPrePProduceOutputDict"][i] = s["ironPrePProduceOutput"]\n\n    s["ironRawElectricityDemandDict"][i] = s["ironRawElectricityDemand"]\n    s["ironRawElectricityUsedDict"][i] = s["ironRawElectricityUsed"]\n    s["ironRawWaterUsedDict"][i] = s["ironRawWaterUsed"]\n    s["ironRawH2UsedDict"][i] = s["ironRawH2Used"]\n    s["ironRawProduceOutputDict"][i] = s["ironRawProduceOutput"]\n\n    s["ironPostPElectricityDemandDict"][i] = s["ironPostPElectricityDemand"]\n    s["ironPostPElectricityUsedDict"][i] = s["ironPostPElectricityUsed"]\n    s["ironPostPWaterUsedDict"][i] = s["ironPostPWaterUsed"]\n    s["ironPostPH2UsedDict"][i] = s["ironPostPH2Used"]\n    s["ironPostPProduceOutputDict"][i] = s["ironPostPProduceOutput"]\n\n    s["cumulativeEmissionsAllowedDict"][i] = s["cumulativeEmissionsAllowed"]\n\n    s["gridElectricityCostDict"][i] = s["gridElectricityCost"]\n    s["gridElectricityRevenueDict"][i] = s["gridElectricityRevenue"]\n    s["gridExportElectricityUsedDict"][i] = s["gridExportElectricityUsed"]\n    s["gridExportElectricityDemandDict"][i] = s["gridExportElectricityDemand"]\n\n    s["electricityNetDict"][i] = s["electricityDistributeOutput"] - s["electricityUsed"]\n    s["waterNetDict"][i] = s["waterDistributeOutput"] - s["waterUsed"]\n    s["h2NetDict"][i] = s["h2DistributeOutput"] - s["h2Used"]\n\n\n    return True\n');__stickytape_write_module('model/update_emissions_levels.py',b'def updateEmissionLevels(i, s, settings):\n    s["electricityProduceGridEmissions"] = (\n        s["electricityProduceGridOutput"] * s["gridElectricityEmissionsFactor"][i]\n    )\n    s["electricityProduceGasTurbinesEmissions"] = (\n        s["electricityProduceGasTurbinesOutput"] * settings["naturalGasToElectricity"]\n    ) / settings["naturalGasToEmissions"]\n    s["electricityDistributeEmissions"] = (\n        s["electricityProduceGridEmissions"]\n        + s["electricityProduceGasTurbinesEmissions"]\n    )\n    if s["electricityDistributeEmissions"] == 0:\n        s["electricityDistributeEmissionsIntensity"] = 0\n    if s["electricityDistributeOutput"] == 0:\n        s["electricityDistributeEmissionsIntensity"] = 0\n    else:\n        s["electricityDistributeEmissionsIntensity"] = (\n            s["electricityDistributeEmissions"] / s["electricityDistributeOutput"]\n        )\n\n    s["waterCumulativeOutput"][i] = (\n        s["waterCumulativeOutput"].get(i - 1, 0) + s["waterDistributeOutput"]\n    )\n    s["h2CumulativeOutput"][i] = (\n        s["h2CumulativeOutput"].get(i - 1, 0) + s["h2DistributeOutput"]\n    )\n#    s["lohcCumulativeOutput"][i] = (\n#        s["lohcCumulativeOutput"].get(i - 1, 0) + s["lohcDistributeOutput"]\n#    )\n#    s["nh3CumulativeOutput"][i] = (\n#        s["nh3CumulativeOutput"].get(i - 1, 0) + s["nh3DistributeOutput"] - s["fertNh3Used"]\n#    )\n#    s["fertCumulativeOutput"][i] = (\n#        s["fertCumulativeOutput"].get(i - 1, 0) + s["fertDistributeOutput"]\n#    )\n #   s["mp1CumulativeOutput"][i] = (\n #       s["mp1CumulativeOutput"].get(i - 1, 0) + s["mp1DistributeOutput"]\n #   )\n    s["ironCumulativeOutput"][i] = (\n        s["ironCumulativeOutput"].get(i - 1, 0) + s["ironDistributeOutput"]\n    )\n\n    s["cumulativeEmissions"][i] = (\n        s["cumulativeEmissions"].get(i - 1, 0)\n        + s["electricityProduceGridEmissions"]\n        + s["electricityProduceGasTurbinesEmissions"]\n    )\n\n    s["cumulativeEmissionsAllowed"] = settings["ironEmissionsIntensityLimit"] * s["ironCumulativeOutput"][i]\n #       settings["lohcEmissionsIntensityLimit"] * s["lohcCumulativeOutput"][i]\n #       + settings["nh3EmissionsIntensityLimit"] * s["nh3CumulativeOutput"][i]\n #       + settings["mp1EmissionsIntensityLimit"] * s["mp1CumulativeOutput"][i]\n #       + settings["fertEmissionsIntensityLimit"] * s["fertCumulativeOutput"][i]\n    return True\n');__stickytape_write_module('model/update_firming_control.py',b'def updateFirmingControl(i, s):\n    s["firmingAllowedDict"][i + 1] = 1\n    if s["cumulativeEmissions"][i] > s["cumulativeEmissionsAllowed"]:\n        s["firmingAllowedDict"][i + 1] = 0\n    return True\n');__stickytape_write_module('model/update_store_levels.py',b'from model.functions import calcStoreLevelNew\n\n\ndef updateStoreLevels(i, s, settings):\n    electricityStoreLevelNew = calcStoreLevelNew(\n        s["electricityStoreLevel"], s["electricityStoreChange"]\n    )\n    s["electricityStoreLevelDict"][i + 1] = electricityStoreLevelNew\n\n    waterStoreLevelNew = calcStoreLevelNew(s["waterStoreLevel"], s["waterStoreChange"])\n    s["waterStoreLevelDict"][i + 1] = waterStoreLevelNew\n\n    h2StoreLevelNew = calcStoreLevelNew(s["h2StoreLevel"], s["h2StoreChange"])\n    s["h2StoreLevelDict"][i + 1] = h2StoreLevelNew\n\n#    lohcStoreLevelNew = calcStoreLevelNew(s["lohcStoreLevel"], s["lohcStoreChange"])\n#    s["lohcStoreLevelDict"][i + 1] = lohcStoreLevelNew\n\n#   nh3StoreLevelNew = calcStoreLevelNew(s["nh3StoreLevel"], s["nh3StoreChange"])\n#    s["nh3StoreLevelDict"][i + 1] = nh3StoreLevelNew\n\n#    fertStoreLevelNew = calcStoreLevelNew(s["fertStoreLevel"], s["fertStoreChange"])\n#    s["fertStoreLevelDict"][i + 1] = fertStoreLevelNew\n\n #   mp1StoreLevelNew = calcStoreLevelNew(s["mp1StoreLevel"], s["mp1StoreChange"])\n #   s["mp1StoreLevelDict"][i + 1] = mp1StoreLevelNew\n\n    ironStoreLevelNew = calcStoreLevelNew(s["ironStoreLevel"], s["ironStoreChange"])\n    s["ironStoreLevelDict"][i + 1] = ironStoreLevelNew\n\n    return True\n');__stickytape_write_module('results/results.py',b'\nfrom results.financial import financial_npv, financial_pmt\n\ndef reorder_dict_alphabetically(d):\n    return {k: d[k] for k in sorted(d)}\n\ndef multiplyArrayByConstant(array, constant):\n    for i in range(0, len(array)):\n        array[i] = array[i] * constant\n    return array\n\n\ndef create_results_object(s, settings):\n    results = {}\n\n    results["benchmarkEnergyInput"] = s["benchmarkEnergyInput"]\n    results["ironPriceAfterCarbon"] = s["ironPriceAfterCarbon"]\n    results["ironValueAdd"] = s["ironValueAdd"]\n    results["breakevenElectricityPrice"] = s["breakevenElectricityPrice"]\n    results["wholesaleElectricityPrice"] = s["wholesaleElectricityPrice"]\n    results["h2DistributeCapacity"] = s["h2DistributeCapacity"]\n    results["waterDistributeCapacity"] = s["waterDistributeCapacity"]\n    results["electricityDistributeCapacity"] = s["electricityDistributeCapacity"]\n\n\n\n\n    #\'empty\' used for plots\n    results["empty"] = multiplyArrayByConstant(list(range(0, settings["simLength"])), 0)\n    normalKeys = [\n        "cumulativeEmissions",\n        "h2CumulativeEmissions",\n        "h2CumulativeOutput",\n        "ironCumulativeEmissions",\n        "ironCumulativeOutput",\n       # "mp1CumulativeEmissions",\n       # "mp1CumulativeOutput",\n       # "nh3CumulativeEmissions",\n       # "nh3CumulativeOutput",\n       # "lohcCumulativeEmissions",\n       # "lohcCumulativeOutput",\n        "waterCumulativeEmissions",\n        "waterCumulativeOutput",\n        "optimised"\n    ]\n    dictKeys = [\n        "networkCharge",\n        "wholesaleElectricityCost",\n        "electricityDistributeDemand",\n        "electricityDistributeOutput",\n        "electricityDistributeRenewableOutput",\n        "electricityProduceGridEmissions",\n        "electricityProduceGridOutput",\n        "electricityProduceFirmingEmissions",\n        "firmingAllowed",\n        "electricityProduceFirmingDemand",\n        "electricityProduceFirmingFull",\n        "electricityProduceFirmingMinimum",\n        "electricityProduceFirmingOutput",\n        "electricityProduceGasTurbinesEmissions",\n        "electricityProduceGasTurbinesOutput",\n        "electricityProduceRenewableOutput",\n        "electricityProduceOutput",\n        "electricityProduceSolarPvOutput",\n        "electricityProduceWindTurbinesOutput",\n        "electricityRawRenewableOutput",\n        "electricityRawSolarPvOutput",\n        "electricityRawWindTurbinesOutput",\n        "electricityStoreLevel",\n        "electricityUsed",\n        "h2DistributeDemand",\n        "h2DistributeOutput",\n        "h2ElectricityDemand",\n        "h2ElectricityUsed",\n        "h2ProduceOutput",\n        "h2StoreLevel",\n        "h2Used",\n        "h2WaterDemand",\n        "h2WaterUsed",\n        "ironDistributeDemand",\n        "ironDistributeOutput",\n        "ironElectricityDemand",\n        "ironElectricityUsed",\n        "ironH2Demand",\n        "ironH2Used",\n        "ironWaterUsed",\n        "ironProduceOutput",\n        "ironStoreLevel",\n        "ironPrePElectricityDemand",\n        "ironPrePElectricityUsed",\n        "ironPrePH2Demand",\n        "ironPrePH2Used",\n        "ironPrePWaterUsed",\n        "ironPrePProduceOutput",\n        "ironRawElectricityDemand",\n        "ironRawElectricityUsed",\n        "ironRawH2Demand",\n        "ironRawH2Used",\n        "ironRawWaterUsed",\n        "ironRawProduceOutput",\n        "ironPostPElectricityDemand",\n        "ironPostPElectricityUsed",\n        "ironPostPH2Demand",\n        "ironPostPH2Used",\n        "ironPostPWaterUsed",\n        "ironPostPProduceOutput",\n     #   "mp1DistributeDemand",\n     #  "mp1DistributeOutput",\n     #   "mp1ElectricityDemand",\n     #   "mp1ElectricityUsed",\n     #   "mp1ProduceOutput",\n     #   "mp1StoreLevel",\n        # "nh3DistributeDemand",\n        # "nh3DistributeOutput",\n        # "nh3ElectricityDemand",\n        # "nh3ElectricityUsed",\n        # "nh3H2Demand",\n        # "nh3H2Used",\n        # "nh3ProduceOutput",\n        # "nh3StoreLevel",\n        # "lohcDistributeDemand",\n        # "lohcDistributeOutput",\n        # "lohcElectricityDemand",\n        # "lohcElectricityUsed",\n        # "lohcH2Demand",\n        # "lohcH2Used",\n        # "lohcProduceOutput",\n        # "lohcStoreLevel",\n        "waterDistributeDemand",\n        "waterDistributeOutput",\n        "waterElectricityDemand",\n        "waterElectricityUsed",\n        "waterProduceOutput",\n        "waterStoreLevel",\n        "waterUsed",\n        # "fertDistributeDemand",\n        # "fertDistributeOutput",\n        # "fertElectricityDemand",\n        # "fertElectricityUsed",\n        # "fertNh3Demand",\n        # "fertNh3Used",\n        # "fertProduceOutput",\n        # "fertStoreLevel",\n        "cumulativeEmissionsAllowed",\n        "gridElectricityCost",\n        "gridElectricityRevenue",\n        "gridExportElectricityUsed",\n        "gridExportElectricityDemand",\n        "electricityNet",\n        "waterNet",\n        "h2Net",\n    ]\n    \n    dictKeys = sorted(dictKeys)\n    \n    resultsKeys = []\n\n    for key in normalKeys:\n        results[key] = list(s[key].values())\n        resultsKeys.append(key)\n\n    for key in dictKeys:\n        newKey = key + "Dict"\n        results[key] = list(s[newKey].values())\n        resultsKeys.append(key)\n    \n    results = reorder_dict_alphabetically(results)\n\n    return results, resultsKeys\n\n\ndef annual_results(settings, results, resultsKeys, variablesUnits):\n    annualResults = {}\n\n    for i in range(len(resultsKeys)):\n        item = resultsKeys[i]\n        annualResults[item] = sum(results[item]) * settings["simLength"]/8760\n\n    annualResultsTable = list(range(0, len(resultsKeys)))\n\n    for i in range(len(resultsKeys)):\n        rowList = list(range(0, 3))\n        item = resultsKeys[i]\n        rowList[0] = item\n        rowList[1] = annualResults[item]\n        rowList[2] = variablesUnits.get(item, "")\n        annualResultsTable[i] = rowList\n\n    checks = {}\n\n    checks["electricitySum"] = annualResults["electricityDistributeOutput"] - annualResults["electricityUsed"]\n    checks["h2Sum"] = annualResults["h2DistributeOutput"] - annualResults["h2Used"]\n    checks["waterSum"] = annualResults["waterDistributeOutput"] - annualResults["waterUsed"]\n\n    return annualResults, checks\n\n\ndef cost_and_revenue(annualResults, settings, s):\n    capex = {}\n    # valueChains = ["electricity", "water", "h2", "lohc", "nh3", "fert", "iron", "mp1"]\n    \n    facilities = [\n        "solarPv",\n        "windTurbines",\n        "gasTurbines",\n        "electricityStore",\n        #"electricityDistribute",\n        "waterProduce",\n        "waterStore",\n        #"waterDistribute",\n        "h2Produce",\n        "h2Store",\n        #"h2Distribute",\n        # "lohcProduce",\n        # "lohcStore",\n        # "lohcDistribute",\n        # "nh3Produce",\n        # "nh3Store",\n        # "nh3Distribute",\n        # "fertProduce",\n        # "fertStore",\n        # "fertDistribute",\n        # "mp1Produce",\n        # "mp1Store",\n        # "mp1Distribute",\n        "ironPrePProduce",\n        "ironRawProduce",\n        "ironPostPProduce",\n        "ironStore",\n        "ironDistribute",\n        "port",\n        "road",\n        "electricityBtmTransmission",\n        "electricityGridTransmission",\n        "gridElectricity",\n    ]\n\n\n    for i in range(0, len(facilities) - 4):\n        capex[facilities[i]] = (\n            settings.get(facilities[i] + "Capacity", 0) * settings.get(facilities[i] + "UnitCapex", 0)\n        )\n    capex["port"] = settings["portCapex"]\n    capex["electricityBtmTransmission"] = (\n        settings["electricityBtmTransmissionDistance"]\n        * settings["electricityBtmTransmissionUnitCapex"]\n        * settings["electricityBtmTransmissionCapacity"]\n        / 1000\n    )\n    capex["electricityGridTransmission"] = (\n        settings["electricityGridTransmissionDistance"]\n        * settings["electricityGridTransmissionUnitCapex"]\n        * settings["electricityGridTransmissionCapacity"]\n        / 1000\n    )\n    capex["road"] = settings["roadDistance"] * settings["roadUnitCapex"]\n    capex["gridElectricity"] = 0\n    capex["electricityDistribute"] = s["electricityDistributeCapacity"] * settings["electricityDistributeUnitCapex"]\n    capex["electricity"] = (\n        capex["solarPv"]\n        + capex["windTurbines"]\n        + capex["gasTurbines"]\n        + capex["electricityStore"]\n        + capex["electricityDistribute"]\n        + capex["electricityBtmTransmission"]\n        + capex["electricityGridTransmission"]\n        + capex["gridElectricity"]\n    )\n    capex["waterDistribute"] = s["waterDistributeCapacity"] * settings["waterDistributeUnitCapex"]\n    capex["water"] = (\n        capex["waterProduce"] + capex["waterStore"] + capex["waterDistribute"]\n    )\n    capex["h2Distribute"] = s["h2DistributeCapacity"] * settings["h2DistributeUnitCapex"]\n    capex["h2"] = capex["h2Produce"] + capex["h2Store"] + capex["h2Distribute"]\n    #capex["lohc"] = capex["lohcProduce"] + capex["lohcStore"] + capex["lohcDistribute"]\n    #capex["nh3"] = capex["nh3Produce"] + capex["nh3Store"] + capex["nh3Distribute"]\n    #capex["fert"] = capex["fertProduce"] + capex["fertStore"] + capex["fertDistribute"]\n    #capex["mp1"] = capex["mp1Produce"] + capex["mp1Store"] + capex["mp1Distribute"]\n    capex["iron"] = capex["ironPrePProduce"] + capex["ironRawProduce"] + capex["ironPostPProduce"] + capex["ironStore"] + capex["ironDistribute"]\n    capex["transport"] = capex["port"] + capex["road"]\n    capex["total"] = (\n        capex["electricity"]\n        + capex["water"]\n        + capex["h2"]\n     #   + capex["lohc"]\n     #   + capex["nh3"]\n     #   + capex["fert"]\n     #   + capex["mp1"]\n        + capex["iron"]\n        + capex["transport"]\n    )\n\n    capexKeys = facilities\n    capexKeys.insert(0,"electricityDistribute")\n    capexKeys.insert(0,"waterDistribute")\n    capexKeys.insert(0,"h2Distribute")\n\n    finex = {}\n    for i in range(0, len(capexKeys) - 1):\n        finex[capexKeys[i]] = -1 * financial_pmt(\n            settings["financeRate"],\n            settings[capexKeys[i] + "Life"],\n            capex[capexKeys[i]],\n        )\n    \n    #Overwrite with renewables specific finance rate\n\n    renewableFacilities = [\n        "solarPv",\n        "windTurbines",\n        "electricityStore",\n        "electricityDistribute",\n        "electricityBtmTransmission",\n        "electricityGridTransmission",\n        "gridElectricity",\n    ]\n    for i in range(0, len(renewableFacilities) - 1):\n        finex[renewableFacilities[i]] = -1 * financial_pmt(\n            settings["financeRateRenewables"],\n            settings[renewableFacilities[i] + "Life"],\n            capex[renewableFacilities[i]],\n        )\n    \n    finex["gridElectricity"] = 0\n    finex["electricity"] = (\n        finex["solarPv"]\n        + finex["windTurbines"]\n        + finex["gasTurbines"]\n        + finex["electricityStore"]\n        + finex["electricityDistribute"]\n        + finex["electricityBtmTransmission"]\n        + finex["electricityGridTransmission"]\n        + finex["gridElectricity"]\n    )\n    finex["water"] = (\n        finex["waterProduce"] + finex["waterStore"] + finex["waterDistribute"]\n    )\n    finex["h2"] = finex["h2Produce"] + finex["h2Store"] + finex["h2Distribute"]\n    #finex["lohc"] = finex["lohcProduce"] + finex["lohcStore"] + finex["lohcDistribute"]\n    #finex["nh3"] = finex["nh3Produce"] + finex["nh3Store"] + finex["nh3Distribute"]\n    #finex["fert"] = finex["fertProduce"] + finex["fertStore"] + finex["fertDistribute"]\n    #finex["mp1"] = finex["mp1Produce"] + finex["mp1Store"] + finex["mp1Distribute"]\n    finex["iron"] = finex["ironPrePProduce"] + finex["ironRawProduce"] + finex["ironPostPProduce"] + finex["ironStore"] + finex["ironDistribute"]\n    finex["transport"] = finex["port"] + finex["road"]\n    finex["total"] = (\n        finex["electricity"]\n        + finex["water"]\n        + finex["h2"]\n    #    + finex["lohc"]\n    #    + finex["nh3"]\n    #    + finex["fert"]\n    #    + finex["mp1"]\n        + finex["iron"]\n        + finex["transport"]\n    )\n\n    opex = {}\n    for i in range(0, len(capexKeys)):\n        opex[capexKeys[i]] = capex[capexKeys[i]] * settings["opexFactor"]\n    opex["electricity"] = (\n        opex["solarPv"]\n        + opex["windTurbines"]\n        + opex["gasTurbines"]\n        + opex["electricityStore"]\n        + opex["electricityDistribute"]\n        + opex["electricityBtmTransmission"]\n        + opex["electricityGridTransmission"]\n        + opex["gridElectricity"]\n    )\n    opex["water"] = opex["waterProduce"] + opex["waterStore"] + opex["waterDistribute"]\n    opex["h2"] = opex["h2Produce"] + opex["h2Store"] + opex["h2Distribute"]\n    #opex["lohc"] = opex["lohcProduce"] + opex["lohcStore"] + opex["lohcDistribute"]\n    #opex["nh3"] = opex["nh3Produce"] + opex["nh3Store"] + opex["nh3Distribute"]\n    #opex["fert"] = opex["fertProduce"] + opex["fertStore"] + opex["fertDistribute"]\n    #opex["mp1"] = opex["mp1Produce"] + opex["mp1Store"] + opex["mp1Distribute"]\n    opex["iron"] = opex["ironPrePProduce"] + opex["ironRawProduce"] + opex["ironPostPProduce"] + opex["ironStore"] + opex["ironDistribute"]\n    opex["transport"] = opex["port"] + opex["road"]\n    opex["total"] = (\n        opex["electricity"]\n        + opex["water"]\n        + opex["h2"]\n    #    + opex["lohc"]\n    #    + opex["nh3"]\n    #    + opex["fert"]\n    #    + opex["mp1"]\n        + opex["iron"]\n        + opex["transport"]\n    )\n\n    resourcex = {}\n    for i in range(0, len(capexKeys)):\n        resourcex[capexKeys[i]] = 0\n\n    resourcex["gasTurbines"] = (\n        settings["naturalGasUnitCost"]\n        * (\n            annualResults["electricityProduceGasTurbinesOutput"]\n            / settings["naturalGasToElectricity"]\n        )\n        / 1000000\n    )\n    # (annualResults["mp1ProduceOutput"]) / settings["mp1OreToMp1"]\n#    resourcex["mp1Produce"] = (\n#        settings["mp1OreUnitCost"]\n#       * (annualResults["mp1ProduceOutput"])\n#        * settings["mp1OreToMp1"]\n#        + settings["mp1ReagentsUnitCost"]\n#        * (annualResults["mp1ProduceOutput"])\n#        * settings["mp1ReagentsToMp1"]\n#    ) / 1000000\n    resourcex["ironPrePProduce"] = (\n        settings["ironOreUnitCost"]\n        * annualResults["ironPrePProduceOutput"]\n        * settings["ironOreToIronPreP"]\n    ) / 1000000\n    resourcex["gridElectricity"] = (\n        annualResults["gridElectricityCost"]\n        / 1000000\n    )\n\n    resourcex["electricity"] = (\n        resourcex["solarPv"]\n        + resourcex["windTurbines"]\n        + resourcex["gasTurbines"]\n        + resourcex["electricityStore"]\n        + resourcex["electricityDistribute"]\n        + resourcex["electricityBtmTransmission"]\n        + resourcex["electricityGridTransmission"]\n        + resourcex["gridElectricity"]\n    )\n    resourcex["water"] = (\n        resourcex["waterProduce"]\n        + resourcex["waterStore"]\n        + resourcex["waterDistribute"]\n    )\n    resourcex["h2"] = (\n        resourcex["h2Produce"] + resourcex["h2Store"] + resourcex["h2Distribute"]\n    )\n    #resourcex["lohc"] = (\n    #    resourcex["lohcProduce"] + resourcex["lohcStore"] + resourcex["lohcDistribute"]\n    #)\n    # resourcex["nh3"] = (\n    #     resourcex["nh3Produce"] + resourcex["nh3Store"] + resourcex["nh3Distribute"]\n    # )\n    # resourcex["fert"] = (\n    #     resourcex["fertProduce"] + resourcex["fertStore"] + resourcex["fertDistribute"]\n    # )\n    # resourcex["mp1"] = (\n    #     resourcex["mp1Produce"] + resourcex["mp1Store"] + resourcex["mp1Distribute"]\n    # )\n    resourcex["iron"] = (\n        resourcex["ironPrePProduce"] + resourcex["ironRawProduce"] + resourcex["ironPostPProduce"] + resourcex["ironStore"] + resourcex["ironDistribute"]\n    )\n    resourcex["transport"] = resourcex["port"] + resourcex["road"]\n    resourcex["total"] = (\n        resourcex["electricity"]\n        + resourcex["water"]\n        + resourcex["h2"]\n    #    + resourcex["lohc"]\n    #    + resourcex["nh3"]\n    #    + resourcex["fert"]\n    #    + resourcex["mp1"]\n        + resourcex["iron"]\n        + resourcex["transport"]\n    )\n\n    carbonex = {}\n    for i in range(0, len(capexKeys)):\n        carbonex[capexKeys[i]] = 0\n\n    carbonex["gridElectricity"] = (settings["carbonPrice"] * annualResults["electricityProduceGridEmissions"])/1000000\n\n    carbonex["gasTurbines"] = (settings["carbonPrice"] * annualResults["electricityProduceGasTurbinesEmissions"])/1000000\n\n    carbonex["electricity"] = carbonex["gridElectricity"] + carbonex["gasTurbines"]\n\n    carbonex["total"] = carbonex["electricity"]\n\n    annualCost = {}\n    for i in range(0, len(capexKeys)):\n        annualCost[capexKeys[i]] = (\n            finex[capexKeys[i]] + opex[capexKeys[i]] + resourcex[capexKeys[i]] + carbonex[capexKeys[i]]\n        )\n\n    annualCost["electricity"] = (\n        annualCost["solarPv"]\n        + annualCost["windTurbines"]\n        + annualCost["gasTurbines"]\n        + annualCost["electricityStore"]\n        + annualCost["electricityDistribute"]\n        + annualCost["electricityBtmTransmission"]\n        + annualCost["electricityGridTransmission"]\n        + annualCost["gridElectricity"]\n    )\n    annualCost["water"] = (\n        annualCost["waterProduce"]\n        + annualCost["waterStore"]\n        + annualCost["waterDistribute"]\n    )\n    annualCost["h2"] = (\n        annualCost["h2Produce"] + annualCost["h2Store"] + annualCost["h2Distribute"]\n    )\n    # annualCost["lohc"] = (\n    #     annualCost["lohcProduce"]\n    #     + annualCost["lohcStore"]\n    #     + annualCost["lohcDistribute"]\n    # )\n    # annualCost["nh3"] = (\n    #     annualCost["nh3Produce"] + annualCost["nh3Store"] + annualCost["nh3Distribute"]\n    # )\n    # annualCost["fert"] = (\n    #     annualCost["fertProduce"]\n    #     + annualCost["fertStore"]\n    #     + annualCost["fertDistribute"]\n    # )\n    # annualCost["mp1"] = (\n    #     annualCost["mp1Produce"] + annualCost["mp1Store"] + annualCost["mp1Distribute"]\n    # )\n    annualCost["iron"] = (\n        annualCost["ironPrePProduce"] + annualCost["ironRawProduce"] + annualCost["ironPostPProduce"] + annualCost["ironStore"] + annualCost["ironDistribute"]\n    )\n    annualCost["transport"] = annualCost["port"] + annualCost["road"]\n    annualCost["total"] = (\n        annualCost["electricity"]\n        + annualCost["water"]\n        + annualCost["h2"]\n#        + annualCost["lohc"]\n#        + annualCost["nh3"]\n#        + annualCost["fert"]\n#        + annualCost["mp1"]\n        + annualCost["iron"]\n        + annualCost["transport"]\n    )\n\n    annualRevenue = {}\n    h2_tax_credit = settings.get("h2TaxCredit", 0)\n    annualRevenue["electricity"] = annualResults["gridElectricityRevenue"] / 1000000\n    \n#   annualRevenue["lohc"] = (\n#        annualResults["lohcDistributeOutput"] * settings["lohcMarketValue"] / 1000\n#        + (annualResults["lohcH2Used"] * h2_tax_credit) / 1000\n#    )\n#    annualRevenue["mp1"] = (\n#       annualResults["mp1DistributeOutput"] * settings["mp1MarketValue"] / 1000\n#    )\n    annualRevenue["iron"] = (\n        annualResults["ironDistributeOutput"] * (settings["ironMarketValue"] + settings["ironMarketEmissionsIntensity"]*settings["carbonPrice"]/1000)/ 1000\n        + (annualResults["ironH2Used"] * h2_tax_credit) / 1000\n#    )\n#    annualRevenue["fert"] = (\n#        annualResults["fertDistributeOutput"] * settings["fertMarketValue"] / 1000\n#        + ((annualResults["nh3H2Used"] * h2_tax_credit) / 1000)\n#       * annualResults["fertNh3Used"]\n#        / annualResults["nh3DistributeOutput"]\n    )\n#    annualRevenue["nh3Export"] = (\n#        annualResults["nh3DistributeOutput"] - annualResults["fertNh3Used"]\n#    ) * (settings["nh3MarketValue"] / 1000) + (\n#        (annualResults["nh3H2Used"] * h2_tax_credit) / 1000\n#    ) * (\n#        annualResults["nh3DistributeOutput"] - annualResults["fertNh3Used"]\n#    ) / annualResults["nh3DistributeOutput"]\n    annualRevenue["total"] = (\n        annualRevenue["electricity"]\n #       + annualRevenue["lohc"]\n#        + annualRevenue["mp1"]\n        + annualRevenue["iron"]\n #       + annualRevenue["fert"]\n #       + annualRevenue["nh3Export"]\n    )\n\n    annualMargin = annualRevenue["total"] - annualCost["total"]\n    annualCash = list(range(settings["npvPeriod"]))\n    for i in range(settings["npvPeriod"]):\n        annualCash[i] = annualMargin\n\n    npv = financial_npv(settings["discountRate"], annualCash)\n\n    \n    capex = reorder_dict_alphabetically(capex)\n    finex = reorder_dict_alphabetically(finex)\n    opex = reorder_dict_alphabetically(opex)\n    resourcex = reorder_dict_alphabetically(resourcex)\n    carbonex = reorder_dict_alphabetically(carbonex)\n    annualCost = reorder_dict_alphabetically(annualCost)\n    annualRevenue = reorder_dict_alphabetically(annualRevenue)  \n\n\n    return {\n        "capex": capex,\n        "finex": finex,\n        "opex": opex,\n        "resourcex": resourcex,\n        "carbonex" : carbonex,\n        "annualCost": annualCost,\n        "annualRevenue": annualRevenue,\n        "annualMargin": annualMargin,\n        "npv": npv,\n    }\n');__stickytape_write_module('results/financial.py',b'def financial_npv(rate, values):\n    return sum(val / (1 + rate) ** i for i, val in enumerate(values))\n\n\ndef financial_pmt(rate, nper, pv, fv=0, when="end"):\n    when_mult = 1 if when == "begin" else 0\n    is_rate_zero = rate == 0\n    temp = (1 + rate) ** nper\n    masked_rate = 1 if is_rate_zero else rate\n    fact = (\n        nper\n        if is_rate_zero\n        else ((1 + masked_rate * when_mult) * (temp - 1) / masked_rate)\n    )\n    return -(fv + pv * temp) / fact\n');__stickytape_write_module('ga.py',b'from math import sqrt\nimport time\nimport copy\nimport random\nfrom multiprocessing import Manager, Pool, cpu_count\nfrom helpers.general import isSystemiser\nfrom parallel import formatPrice, setupResultsTable\n\nfrom model.simulation import simulation\n\n# Configuration\n# POPULATION_SIZE = cpu_count() * 5  # Ensure the population size is a multiple of the number of CPUs\nPOPULATION_SIZE = round(8 * sqrt(cpu_count()) + 2 * cpu_count())\nMUTATION_RATE = 0.1\nTOURNAMENT_SIZE = 5\nELITISM = True\n\ndef update_results_tables(answer, flex_values, results_table, results_table_print):\n    """\n    Update results tables with the results of the simulation.\n    """\n    row = list(flex_values)  # Add the flex values to the row\n    row.extend([\n        answer[\'npv\'],\n        answer[\'capex\'],\n        answer[\'opex\'],\n        answer[\'finex\'],\n    ])\n    results_table.append(row)\n    print_row = list(flex_values)  # Add the flex values to the print row\n    print_row.extend([\n        formatPrice(answer.get(\'npv\')),\n        formatPrice(answer.get(\'capex\')),\n        formatPrice(answer.get(\'opex\')),\n        formatPrice(answer.get(\'finex\')),\n    ])\n    results_table_print.append(print_row)\n\ndef generate_individual_from_seed(flex_data, start_seed):\n    """\n    Generate a single individual with seed values.\n    """\n    def get_var_value(var):\n        if var[\'name\'] in start_seed:\n            return start_seed[var[\'name\']]\n        return round(random.uniform(var["min"], var["max"])) if var.get("round", False) else random.uniform(var["min"], var["max"])\n    return {\n        var["name"]: get_var_value(var)\n        for var in flex_data\n    }\n\ndef generate_individual(flex_data):\n    """\n    Generate a single individual with random values within the given ranges.\n    """\n    return {\n        var["name"]: round(random.uniform(var["min"], var["max"])) if var.get("round", False) else random.uniform(var["min"], var["max"])\n        for var in flex_data\n    }\n\ndef generate_initial_population(flex_data, existing_hashes, start_seed):\n    """\n    Generate the initial population of unique individuals.\n    """\n    population = []\n    if start_seed:\n        population.append(generate_individual_from_seed(flex_data, start_seed))\n    while len(population) < POPULATION_SIZE:\n        individual = generate_individual(flex_data)\n        indiv_hash = hash_individual(individual)\n        if indiv_hash not in existing_hashes:\n            population.append(individual)\n            existing_hashes.add(indiv_hash)\n    return population\n\ndef hash_individual(individual):\n    """\n    Create a hash for an individual by converting its values to a sorted tuple string.\n    """\n    return str(sorted(individual.items()))\n\ndef evaluate_population(state, settings, demands, units, population, results_table, results_table_print, remaining_time):\n    """\n    Evaluate the population using multiprocessing.\n    """\n    if isSystemiser():\n        start_time = time.time()\n        time_limit = remaining_time\n        answers = {}\n        fitness_scores = []\n\n        for idx, individual in enumerate(population):\n            if time.time() - start_time > time_limit:\n                break\n\n            run_simulation_extract_values(idx, state, settings, demands, units, individual, answers)\n\n        for idx, individual in enumerate(population):\n            result = answers.get(idx)\n            if result:\n                fitness = result[\'npv\']\n                fitness_scores.append((individual, fitness, result))\n                update_results_tables(result, list(individual.values()), results_table, results_table_print)\n\n        return fitness_scores\n\n    cpus = cpu_count()\n    with Manager() as manager:\n        answers = manager.dict()\n        pool = Pool(processes=round(cpus))\n        for idx, individual in enumerate(population):\n            pool.apply_async(\n                run_simulation_extract_values,\n                args=(idx, state, settings, demands, units, individual, answers)\n            )\n        pool.close()\n        pool.join()\n\n        fitness_scores = []\n        for idx, individual in enumerate(population):\n            result = answers.get(idx)\n            if result:\n                fitness = result[\'npv\']\n                fitness_scores.append((individual, fitness, result))\n                update_results_tables(result, list(individual.values()), results_table, results_table_print)\n    return fitness_scores\n\ndef run_simulation_extract_values(idx, state, settings, demands, units, individual, answers):\n    """\n    Run the simulation and extract necessary values.\n    """\n    sim_state = copy.deepcopy(state)\n    sim_settings = copy.deepcopy(settings)\n    sim_demands = copy.deepcopy(demands)\n    sim_units = copy.deepcopy(units)\n    sim_settings.update(individual)\n    answer = simulation(sim_state, sim_settings, sim_demands, sim_units)\n    # Extract the necessary values only\n    npv = answer[\'results\'][\'npv\']\n    capex = answer[\'results\'][\'capex\'][\'total\']\n    opex = answer[\'results\'][\'opex\'][\'total\']\n    finex = answer[\'results\'][\'finex\'][\'total\']\n    result = {\n        \'npv\': npv,\n        \'capex\': capex,\n        \'opex\': opex,\n        \'finex\': finex,\n        \'full_results\': answer[\'results\'],\n        \'full_s\': answer[\'s\'],\n    }\n    answers[idx] = result\n    print(f"Simulation {idx + 1}/{POPULATION_SIZE} for individual {individual} finished.")\n\ndef select_parents(population):\n    """\n    Select parents for crossover.\n    """\n    selected = random.sample(population, len(population))\n    selected.sort(key=lambda x: x[1], reverse=True)\n    return selected[0][0], selected[1][0]\n\ndef crossover(parent1, parent2):\n    """\n    Perform crossover to generate a child.\n    """\n    child = {}\n    for key in parent1:\n        child[key] = parent1[key] if random.random() < 0.5 else parent2[key]\n    return child\n\ndef mutate(individual, flex_data):\n    """\n    Mutate an individual with a given probability.\n    """\n    for var in flex_data:\n        if random.random() < MUTATION_RATE:\n            individual[var["name"]] = round(random.uniform(var["min"], var["max"])) if var.get("round", False) else random.uniform(var["min"], var["max"])\n    return individual\n\ndef genetic_algorithm(input_data, run_time, state, settings, demands, units, start_seed = 0):\n    """\n    Run the genetic algorithm for a specified amount of time.\n    """\n    start = time.time()\n    flex_data = input_data[\'flexs\']\n\n    existing_hashes = set()\n    population = generate_initial_population(flex_data, existing_hashes, start_seed)\n    best_individual = None\n    flex_vars = [var["name"] for var in flex_data]\n    results_table, results_table_print = setupResultsTable(True, flex_vars)\n\n    generation = 0\n    while time.time() - start < run_time:\n        print(f"\\nStarting generation {generation + 1}...")\n        remaining_time = run_time - (time.time() - start)\n        fitness_scores = evaluate_population(state, settings, demands, units, population, results_table, results_table_print, remaining_time)\n        fitness_scores.sort(key=lambda x: x[1], reverse=True)\n\n        if best_individual is None or fitness_scores[0][1] > best_individual[1]:\n            best_individual = fitness_scores[0]\n\n        new_population = [fitness_scores[0][0]] if ELITISM else []\n        while len(new_population) < POPULATION_SIZE:\n            parent1, parent2 = select_parents(fitness_scores)\n            child = crossover(parent1, parent2)\n            child = mutate(child, flex_data)\n            indiv_hash = hash_individual(child)\n            if indiv_hash not in existing_hashes:\n                new_population.append(child)\n                existing_hashes.add(indiv_hash)\n\n        population = new_population\n        generation += 1\n\n    return best_individual, {"table": results_table, "displayTable": results_table_print}');__stickytape_write_module('helpers/general.py',b'import sys\n\ndef toFloat(text: str):\n    if isinstance(text, (float, int)):\n        return text\n    return float(text.replace(",", "."))\n\ndef roundTo(number, decimalPoints):\n    factor = pow(10, decimalPoints)\n    return round(number * factor) / factor\n\ndef isSystemiser():\n    return "pyodide" in sys.modules\n');__stickytape_write_module('parallel.py',b'from dataclasses import dataclass\nfrom typing import Dict, List, Tuple\nimport copy\nfrom multiprocessing import Manager, Pool, cpu_count\nimport random\n\nfrom model.simulation import simulation\n\n\n\ndef determineFlexRuns(\n    flexVariable: str, flexStart: float, flexEnd: float, flexSteps: int, flexRound: bool\n) -> Tuple[str, float]:\n    interval = (flexEnd - flexStart) / (flexSteps + 1)\n    flexRuns: Tuple[str, float] = []\n    if flexVariable and flexStart != flexEnd and interval and flexStart < flexEnd:\n        flexRange = []\n        point = flexStart\n        while point < (flexEnd + 0.000001):\n            flexRange.append(point)\n            point += interval\n            if flexRound:\n                point = round(point)\n        for run in flexRange:\n            flexRuns.append((flexVariable, run))\n    return flexRuns\n\n\n@dataclass\nclass SimulationRunMetaData:\n    uid: int\n    overrides: Dict\n    flexVariables: str\n    flexValues: float\n\n\ndef buildRunList(\n    flex: bool = True,\n    flexVariable: str = "",\n    flexStart: float = 0.0,\n    flexEnd: float = 0.0,\n    flexSteps: int = 1,\n    flexRound: bool = False\n) -> List[SimulationRunMetaData]:\n    runs: List[SimulationRunMetaData] = []\n    flexRuns = (\n        determineFlexRuns(\n            flexVariable=flexVariable,\n            flexStart=flexStart,\n            flexEnd=flexEnd,\n            flexSteps=flexSteps,\n            flexRound=flexRound\n        )\n        if flex\n        else []\n    )\n    runCount = 0\n    for flexInfo in flexRuns:\n        flexOverrides = {flexInfo[0]: flexInfo[1]}\n        runs.append(\n            SimulationRunMetaData(\n                runCount,\n                overrides=flexOverrides,\n                flexVariables=[flexInfo[0]],\n                flexValues=[flexInfo[1]],\n            )\n        )\n        runCount += 1\n    return runs\n\n\ndef buildRandomRunList(flex_variables: List[Dict], number_of_runs: int) -> List[SimulationRunMetaData]:\n    runs: List[SimulationRunMetaData] = []\n\n    for i in range(number_of_runs):\n        overrides = {}\n        flex_var_names = []\n        flex_var_values = []\n\n        for var in flex_variables:\n            name = var["name"]\n            min_val = var["min"]\n            max_val = var["max"]\n            round_val = var.get("round", False)\n\n            random_value = random.uniform(min_val, max_val)\n            if round_val:\n                random_value = round(random_value)\n\n            overrides[name] = random_value\n            flex_var_names.append(name)\n            flex_var_values.append(random_value)\n\n        runs.append(\n            SimulationRunMetaData(\n                uid=i,\n                overrides=overrides,\n                flexVariables=flex_var_names,\n                flexValues=flex_var_values\n            )\n        )\n\n    return runs\n\n@dataclass\nclass DisplayResultItem():\n    displayName: str\n    decimals: int\n    price: bool\n    key1: str\n    key2: str | None\n\ndisplayItems = [\n    DisplayResultItem(displayName=\'NPV\', decimals=2, price=True, key1=\'npv\', key2=None),\n    DisplayResultItem(displayName=\'CAPEX\', decimals=2, price=True, key1=\'capex\', key2=\'total\'),\n    DisplayResultItem(displayName=\'OPEX\', decimals=2, price=True, key1=\'opex\', key2=\'total\'),\n    DisplayResultItem(displayName=\'FINEX\', decimals=2, price=True, key1=\'finex\', key2=\'total\'),\n\n    # DisplayResultItem(displayName=\'RESOURCEX\', decimals=2, price=True, key1=\'resourcex\', key2=\'total\'),\n    # DisplayResultItem(displayName=\'annualCost\', decimals=2, price=True, key1=\'annualCost\', key2=\'total\'),\n    # DisplayResultItem(displayName=\'annualRevenue\', decimals=2, price=True, key1=\'annualRevenue\', key2=\'total\'),\n    # DisplayResultItem(displayName=\'annualMargin\', decimals=2, price=True, key1=\'annualMargin\', key2=None),\n\n    # DisplayResultItem(displayName=\'iron Supply\', decimals=2, price=False, key1=\'annualResults\', key2=\'ironProduceOutput\'),\n    # DisplayResultItem(displayName=\'LOHC Supply\', decimals=2, price=False, key1=\'annualResults\', key2=\'lohcProduceOutput\'),\n    # DisplayResultItem(displayName=\'Fert Supply\', decimals=2, price=False, key1=\'annualResults\', key2=\'fertProduceOutput\'),\n    # DisplayResultItem(displayName=\'NH3 Supply\', decimals=2, price=False, key1=\'annualResults\', key2=\'nh3ProduceOutput\'),\n    # DisplayResultItem(displayName=\'MP1 Supply\', decimals=2, price=False, key1=\'annualResults\', key2=\'mp1ProduceOutput\'),\n]\n\ndef setupResultsTable(flex: bool, flexVariables: List[str] = []):\n    header = [item.displayName for item in displayItems]\n    if flex and len(flexVariables) > 0:\n        header[0:0] = flexVariables\n    resultsTable = [header]\n    resultsTablePrint = [header]\n    return [resultsTable, resultsTablePrint]\n\n\ndef formatPrice(amount: float):\n    if amount > 250000:\n        value = round(amount / 1000000, 2)\n        return f"${value} mil"\n    if amount > 25000:\n        value = round(amount / 1000, 2)\n        return f"${value} K"\n    value = round(amount, 2)\n    return f"${value}"\n\n\ndef updateResultsTables(answer, flex_values, resultsTable, resultsTablePrint):\n    results = answer[\'results\']\n    row = []\n    for item in displayItems:\n        value = results[item.key1][item.key2] if item.key2 is not None else results[item.key1]\n        row.append(value)\n    if len(flex_values) > 0:\n        row[0:0] = flex_values\n    resultsTable.append(row)\n    printRow = []\n    for item in displayItems:\n        value = results[item.key1][item.key2] if item.key2 is not None else results[item.key1]\n        if item.price:\n            printRow.append(formatPrice(value))\n        else:\n            printRow.append(round(value, item.decimals))\n    if len(flex_values) > 0:\n        printRow[0:0] = flex_values\n    resultsTablePrint.append(printRow)\n\n\ndef runSimulationScenarioSharedAnswerWrapper(\n    state, settings, demands, units, run: SimulationRunMetaData, answers\n):\n    runAnswer = simulation(state, settings, demands, units)\n    answers[run.uid] = runAnswer\n    if len(run.flexVariables) > 0:\n        print(f"Done {run.flexVariables} -> {run.flexValues}")\n    else:\n        print("Done")\n\n\ndef printStartProcess(run):\n    flexString = (\n        f"Flex: {run.flexVariables} -> {run.flexValues}"\n        if len(run.flexVariables) > 0\n        else ""\n    )\n    print(f"Starting Process for {flexString}")\n\n\n\ndef execute_multiple_runs_common(\n    state,\n    settings,\n    demands,\n    units,\n    runs,\n    flexVariables\n):\n    cpus = cpu_count()\n    print(f"Number of CPU Cores: {cpus}")\n    processes = []\n    [resultsTable, resultsTablePrint] = setupResultsTable(True, flexVariables)\n    with Manager() as manager:\n        answers = manager.dict()\n        pool = Pool(processes=round(cpus * 1.5))  # X is the number of processes you want to execute in parallel\n        for run in runs:\n            printStartProcess(run)\n            myState = copy.deepcopy(state)\n            mySettings = copy.deepcopy(settings)\n            myDemands = copy.deepcopy(demands)\n            myUnits = copy.deepcopy(units)\n            mySettings.update(run.overrides)\n            pool.apply_async(\n                runSimulationScenarioSharedAnswerWrapper,\n                args=(myState, mySettings, myDemands, myUnits, run, answers),\n            )\n        pool.close()\n        pool.join()\n        for proc in processes:\n            proc.join()\n        for run in runs:\n            answer = answers.get(run.uid)\n            flexValues = run.flexValues if len(run.flexVariables) > 0 else None\n            updateResultsTables(answer, flexValues, resultsTable, resultsTablePrint)\n    return {\n        "table": resultsTable,\n        "displayTable": resultsTablePrint,\n    }\n\ndef execute_multiple_runs(\n    state,\n    settings,\n    demands,\n    units,\n    flex=True,\n    flexVariable="simLength",\n    flexStart=500,\n    flexEnd=4000,\n    flexSteps=100,\n    flexRound=False\n):\n    runs = buildRunList(\n        flex=flex,\n        flexVariable=flexVariable,\n        flexStart=flexStart,\n        flexEnd=flexEnd,\n        flexSteps=flexSteps,\n        flexRound=flexRound\n    )\n    return execute_multiple_runs_common(state, settings, demands, units, runs, [flexVariable])\n\ndef execute_random_runs(\n    state,\n    settings,\n    demands,\n    units,\n    flexData,\n    num_runs\n):\n    runs = buildRandomRunList(flexData, num_runs)\n    flex_names = [var["name"] for var in flexData]\n    return execute_multiple_runs_common(state, settings, demands, units, runs, flex_names)\n');__stickytape_write_module('sys_logging.py',b'from helpers.singleton import SingletonMeta\nfrom helpers.general import isSystemiser\n\nclass Logging(metaclass=SingletonMeta):\n    def __init__(self):\n        self.logs = []\n        self.enabled = False\n\n    def reset(self):\n        self.logs = []\n\n    def setEnabled(self, on: bool):\n        self.enabled = on\n\n    def add(\n        self,\n        message: str,\n    ):\n        if not self.enabled:\n            return\n        if not isSystemiser():\n            print(message)\n        self.logs.append(message)\n\n    def read(self):\n        return self.logs\n\nlogs = Logging()\n\ndef setLoggingEnabled(enabled):\n    logs.setEnabled(enabled)\n\ndef log(message):\n    logs.add(message)\n\ndef getLog():\n    return logs.read()\n\ndef resetLogs():\n    logs.setEnabled(False)\n    logs.reset()\n');__stickytape_write_module('helpers/singleton.py',b'class SingletonMeta(type):\n    """\n    The Singleton class can be implemented in different ways in Python. Some\n    possible methods include: base class, decorator, metaclass. We will use the\n    metaclass because it is best suited for this purpose.\n    """\n\n    _instances = {}\n\n    def __call__(cls, *args, **kwargs):\n        """\n        Possible changes to the value of the `__init__` argument do not affect\n        the returned instance.\n        """\n        if cls not in cls._instances:\n            instance = super().__call__(*args, **kwargs)\n            cls._instances[cls] = instance\n        return cls._instances[cls]\n');__stickytape_write_module('input/local.py',b'import json\n\ndef convert_keys_to_ints(d):\n    if isinstance(d, dict):\n        return {int(k) if k.isdigit() else k: convert_keys_to_ints(v) for k, v in d.items()}\n    elif isinstance(d, list):\n        return [convert_keys_to_ints(i) for i in d]\n    else:\n        return d\n\ndef reorder_dict_alphabetically(d):\n    return {k: d[k] for k in sorted(d)}\n\ndef loadLocalInputData():\n    state = {}\n    with open("./data/state.json") as f:\n        state = convert_keys_to_ints(json.loads(f.read()))\n\n    settings = {}\n    with open("./data/settings.json") as f:\n        settings = json.loads(f.read())\n\n    units = {}\n    with open("./data/units.json") as f:\n        units = json.loads(f.read())\n\n    state = reorder_dict_alphabetically(state)\n    settings = reorder_dict_alphabetically(settings)\n    units = reorder_dict_alphabetically(units)  \n\n\n\n    return state, settings, units\n');__stickytape_write_module('output/local.py',b'def printLocalOutput(answer):\n    print(answer["s"]["electricityDistributeDemand"])\n    print(answer["results"]["npv"])\n    # print(answer["results"]["results"]["cumulativeEmissions"][8759])\n');import time;from model.simulation import simulation;from ga import genetic_algorithm;from sys_logging import log,setLoggingEnabled;from input.local import loadLocalInputData;from output.local import printLocalOutput;from helpers.status import systemiserStatusMessage;from helpers.general import isSystemiser;temp_input_data={_B:[{_D:'solarPvCapacity',_E:0,_F:4000,_G:_A},{_D:'windTurbinesCapacity',_E:0,_F:4000,_G:_A},{_D:'gasTurbinesCapacity',_E:0,_F:1000,_G:_A}],_C:{}}
	def set__sysUpdateStatus(in_put):global __sysUpdateStatus;__sysUpdateStatus=in_put
	def run(state,settings,units):
		H='table';D=units;C=state;B=settings;A=B.get('optimise',{'on':False})
		if A['on']:I=A.get(_B,[]);J=A.get(_C,{});K={_B:I,_C:J};L=A.get('seed',{});M,E=genetic_algorithm(K,A['timeLimit'],C,B,D,L);F,N,G=M;print('Best result: ',F);print('GA Table',E[H]);return{'s':G['full_s'],'results':G['full_results'],'ga_table':E[H],'best_individual':F}
		return simulation(C,B,D)
	def systemiserRun(state,settings,units):systemiserStatusMessage('Running');setLoggingEnabled(_A);return run(state,settings,units)
	def localRun():A,B,C=loadLocalInputData();return run(A,B,C)
	if __name__=='__main__':
		if not isSystemiser():setLoggingEnabled(_A);log('Running Development Test');start_time=time.time();answer=localRun();printLocalOutput(answer);log('');log('-~ %s seconds ~-'%(time.time()-start_time))